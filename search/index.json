[{"content":" 前言：\n个人喜好问题，软件的安装不喜欢用exe安装，更喜欢用压缩包形式进行安装，这样方便管理，也方便卸载 所以下面的python也是以压缩包形式进行搭建，也就是免安装或绿色版 1 Python安装 (1) 前往Python官网，选择要下载的版本，点击对应的download (2) 点击下载对应电脑位数的Windows embeddable package包 (3) 下载完后直接解压 (4) 配置环境变量 此电脑 -\u0026gt; 鼠标右键 -\u0026gt; 属性 -\u0026gt; 高级系统设置 -\u0026gt; 环境变量 将python文件夹路径加入到path中 (5) 打开命令行，输入python -V，正常显示版本号则安装成功 2 Pip安装 pip是Python官方提供的包管理工具，用于安装Python第三方库， pip安装包后，可以不用再下载安装包，直接使用命令行安装，方便管理，也方便卸载 所以搭建python环境基本都要安装pip (1) 前往Pypi，下载get-pip.py文件(Ctrl+S保存) 上方标签可查看支持的python版本 (2) 下载后放入python文件夹，打开命令行运行python get-pip.py安装 (3) 修改python312._pth，将import site的注释去掉，允许Python加载site-packages目录 不同版本文件名中的数字不一致，按自己实际情况修改对应的pth文件 (4) 将安装pip产生的Scripts文件夹加入到环境变量中(参考python安装) (5) 打开命令行输入pip -V，正常显示版本号则安装成功 3 修改Pip镜像源 默认安装的pip使用的是Pypi官方源，速度很慢 为了保证下载速度，推荐将镜像源修改为国内镜像源 这边推荐的镜像源为阿里云(https://mirrors.aliyun.com/pypi/simple/) 运行命令pip config set global.index-url 镜像源地址 会自动在C:\\Users\\用户名\\AppData\\Roaming\\pip创建配置文件pip.ini ","date":"2025-05-14T14:08:02+08:00","permalink":"https://letere-gzj.github.io/hugo-stack/p/python/build-env/","title":"【Python】Windows搭建Python环境"},{"content":" 1 实现方法 (1) 创建layouts/partials/widget/xxx.html文件，文件名随意\n(2) 按照以下的模板，把对应的html，script，css代码复制进去\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div\u0026gt; \u0026lt;!--html内容--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // script内容 \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* css样式 */ \u0026lt;/style\u0026gt; (3) 修改hugo.yaml文件，在params.widgets中添加对应widget的名称 2 示例 2.1 时钟组件 时钟组件: letere-gzj/pure-css3-clock 演示地址 (1) 创建layouts/partials/widget/clock.html文件 (2) 按照实现方法中给出的模板，把html，script，css复制进去 html内容位置: pure-css3-clock/index.html script内容位置: pure-css3-clock/index.html css样式位置: pure-css3-clock/css/style.css (3) 修改hugo.yaml文件，在params.widgets中添加clock (4) 项目启动后，样式不太对，需对样式进行二次调整，来适配主题 (4) 修改css样式，将对应的样式进行注释(删除)和添加 tips: 没演示到的样式不要乱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 .clock-wrapper { /* position: absolute; */ /* top: 0; */ /* left: 0; */ /* width: 100%; */ /* height: 100%; */ /* background-color: #eceef0; */ position: relative; width: 460px; height: 460px; zoom: 0.4; ... } .clock-border { /* top: 60px; */ /* bottom: 0; */ /* left: 0; */ /* right: 0; */ ... } (5) 刷新项目，样式正常，时钟组件引入成功 这是我改好的clock.html，可以直接下载使用(Ctrl+S保存)，下载后将后缀名改回html即可 ","date":"2025-05-06T17:46:24+08:00","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-widget/","title":"【Hugo】Stack主题使用自定义widget"},{"content":" 前言：\n官方文档：ShardingSphere 本篇文章基于5.5.2版本所编写，其他版本可能存在差异 1 数据准备 （1）表sql 1 2 3 4 5 6 CREATE TABLE `t_user` ( `user_id` bigint NOT NULL COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(50) NULL COMMENT \u0026#39;用户名\u0026#39;, `sex` tinyint(1) NULL COMMENT \u0026#39;性别\u0026#39;, PRIMARY KEY (`user_id`) ); （2）数据库表结构 1 2 3 4 5 6 7 8 9 10 - sharding - 任意表 - sharding_0 - t_user_0 - t_user_1 - sharding_1 - t_user_0 - t_user_1 （3）按照上面的sql，以及数据库表结构，创建好数据库和表 2 ShardingSphere-JDBC 2.1 基本引入 （1）依赖引入 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.shardingsphere/shardingsphere-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shardingsphere\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shardingsphere-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; （2）创建shardingsphere配置文件shardingsphere-config.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # 数据源配置 dataSources: default_ds: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding?serverTimezone=GMT%2B8 username: letere password: 123456 ds_0: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding_0?serverTimezone=GMT%2B8 username: letere password: 123456 ds_1: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding_1?serverTimezone=GMT%2B8 username: letere password: 123456 # 规则配置 rules: # 单表配置(不分库分表的表) - !SINGLE tables: - \u0026#34;default_ds.*\u0026#34; # 广播表配置(分库分表的表) - !BROADCAST tables: - \u0026#34;ds_0.t_user\u0026#34; - \u0026#34;ds_1.t_user\u0026#34; - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 库分片策略 databaseStrategy: standard: shardingColumn: user_id shardingAlgorithmName: user_database_inline # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_table_inline bindingTables: - t_user # 分片算法定义 shardingAlgorithms: user_database_inline: type: INLINE props: algorithm-expression: ds_${user_id % 2} user_table_inline: type: INLINE props: algorithm-expression: t_user_${sex % 2} # sql打印调试 props: sql-show: true （3）application.yaml引入shardingsphere配置文件 1 2 3 4 spring: datasource: driver-class-name: org.apache.shardingsphere.driver.ShardingSphereDriver url: jdbc:shardingsphere:classpath:shardingsphere-config.yaml （4）以上就成功引入实现了分库分表，对t_user进行新增操作，会触发分库分表策略，对于其他不分库分表的表就，直接在default_ds进行数据操作 2.2 自定义分片算法类 （1）实现ShardingAlgorithm的子接口，实现分片算法，下边以StandardShardingAlgorithm举例 StandardShardingAlgorithm ComplexKeysShardingAlgorithm HintShardingAlgorithm （2）创建自定义类，实现里面的方法 collection：分片表名集合 preciseShardingValue：分片字段值 rangeShardingValue：分片字段范围值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CustomStandardShardingAlgorithm implements StandardShardingAlgorithm\u0026lt;Integer\u0026gt; { @Override public String doSharding(Collection\u0026lt;String\u0026gt; collection, PreciseShardingValue\u0026lt;Integer\u0026gt; preciseShardingValue) { // TODO: 分表业务处理（按自己实际业务修改） int tableNo = preciseShardingValue.getValue() % 2; // 返回对应的表名(表名_no) return preciseShardingValue.getLogicTableName() + \u0026#34;_\u0026#34; + tableNo; } @Override public Collection\u0026lt;String\u0026gt; doSharding(Collection\u0026lt;String\u0026gt; collection, RangeShardingValue\u0026lt;Integer\u0026gt; rangeShardingValue) { // TODO: 范围查询分表业务处理，一般用时间来分表的会使用到（按自己实际业务修改） // 返回对应表名集合 return collection; } } （3）在shardingsphere-config.yaml中，配置自定义分片算法类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 rules: - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_custom_standard # 分片算法定义 shardingAlgorithms: user_custom_standard: type: CLASS_BASED props: strategy: STANDARD algorithmClassName: com.xxxx.CustomStandardShardingAlgorithm 3 ShardingSphere-Proxy 下面ShardingSphere-Proxy的安装使用，是以windows版为主\n3.1 基本引入 （1）前往shardingsphere，下载shardingsphere-proxy二进制包 （2）命令行输入tar -zxvf apache-shardingsphere-5.5.2-shardingsphere-proxy-bin.tar.gz进行解压（包名，版本号按实际情况填写）\n（3）创建ex-lib文件夹，下载mysql驱动，并放入\n（4）修改conf/global.yaml，配置权限和属性 1 2 3 4 5 6 7 8 9 10 11 12 # 权限验证 authority: users: - user: root@% password: root admin: true privilege: type: ALL_PERMITTED props: # sql打印 sql-show: true （5）修改conf/database-sharding.yaml，配置数据源和分片规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 数据库名 databaseName: sharding_db # 数据源 dataSources: default_ds: url: jdbc:mysql://127.0.0.1:3306/sharding?serverTimezone=GMT%2B8 username: letere password: 123456 ds_0: url: jdbc:mysql://127.0.0.1:3306/sharding_0?serverTimezone=GMT%2B8 username: letere password: 123456 ds_1: url: jdbc:mysql://127.0.0.1:3306/sharding_1?serverTimezone=GMT%2B8 username: letere password: 123456 # 规则配置 rules: # 单表配置(不分库分表的表) - !SINGLE tables: - \u0026#34;default_ds.*\u0026#34; # 广播表配置(分库分表的表) - !BROADCAST tables: - \u0026#34;ds_0.t_user\u0026#34; - \u0026#34;ds_1.t_user\u0026#34; - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 库分片策略 databaseStrategy: standard: shardingColumn: user_id shardingAlgorithmName: user_database_inline # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_table_inline bindingTables: - t_user # 分片算法定义 shardingAlgorithms: user_database_inline: type: INLINE props: algorithm-expression: ds_${user_id % 2} user_table_inline: type: INLINE props: algorithm-expression: t_user_${sex % 2} （6）运行bin/start.bat，命令行没终止即启动成功，默认端口3307，可以前往logs/stdout.log查看具体启动日志 3.2 连接使用 （1）可以通过原生mysql命令行，进行连接 运行命令mysql -P3307 -uroot -proot （2）用springboot连接的话，就将数据源配置为shardingsphere-proxy服务就好 1 2 3 4 5 spring: datasource: url: \u0026#39;jdbc:mysql://127.0.0.1:3307/sharding_db?serverTimezone=GMT%2B8\u0026#39; username: root password: root 3.3 自定义分片算法类 3.3.1 自定义算法类打包 （1）创建标准的maven目录结构，用于打包 1 2 3 4 5 6 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ └── resources/ └── pom.xml （2）创建自定义算法类(具体看shardingsphere-jdbc)，并放入上面的maven项目中 1 2 3 4 5 6 7 8 9 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ │ └── com/ │ │ └── example/ │ │ └── CustomShardingAlgorithm.java │ └── resources/ └── pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.example; import org.apache.shardingsphere.sharding.api.sharding.standard.PreciseShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.RangeShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.StandardShardingAlgorithm; import java.util.Collection; public class CustomShardingAlgorithm implements StandardShardingAlgorithm\u0026lt;Integer\u0026gt; { @Override public String doSharding(Collection\u0026lt;String\u0026gt; collection, PreciseShardingValue\u0026lt;Integer\u0026gt; preciseShardingValue) { // TODO: 分表业务处理（按自己实际业务修改） int tableNo = preciseShardingValue.getValue() % 2; // 返回对应的表名(表名_no) return preciseShardingValue.getLogicTableName() + \u0026#34;_\u0026#34; + tableNo; } @Override public Collection\u0026lt;String\u0026gt; doSharding(Collection\u0026lt;String\u0026gt; collection, RangeShardingValue\u0026lt;Integer\u0026gt; rangeShardingValue) { // TODO: 范围查询分表业务处理，一般用时间来分表的会使用到（按自己实际业务修改） // 返回对应表名集合 return collection; } } （3）在resources目录下创建META-INF/services/org.apache.shardingsphere.sharding.spi.ShardingAlgorithm文件，并填写上面自定义算法类的全限定名 全限定类名：com.example.CustomShardingAlgorithm 1 2 3 4 5 6 7 8 9 10 11 12 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ │ └── com/ │ │ └── example/ │ │ └── CustomShardingAlgorithm.java │ └── resources/ │ └── META-INF/ │ └── services/ │ └── org.apache.shardingsphere.sharding.spi.ShardingAlgorithm └── pom.xml （4）修改pom.xml，配置打包需要的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;project\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-sharding-algorithm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- ShardingSphere依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shardingsphere\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shardingsphere-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- java版本，看情况修改 --\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;utf8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; （5）执行mvn clean package命令，用maven进行打包，生成的jar包在target文件夹下 3.3.2 proxy配置自定义分片算法类 （1）将上面打包好的jar包复制到ext-lib文件夹下\n（2）修改conf/database-sharding.yaml，配置自定义算法类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 规则配置 rules: - !SHARDING # 表分片配置 tables: t_user: tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: custom_inline # 分片算法定义 shardingAlgorithms: custom_inline: type: CLASS_BASED props: strategy: STANDARD algorithmClassName: com.example.CustomShardingAlgorithm （3）重启shardingsphere-proxy服务，即可使用自定义算法类 ","date":"2025-03-28T17:31:02+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/java/shardingsphere/cover_hu2142890986032520167.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/java/shardingsphere/","title":"【Java】SpringBoot整合ShardingSphere"},{"content":" 前言：\n博客文章统计组件个人找到了两个，分别是不蒜子，以及vercount 不蒜子比较老，但很稳定，到现在仍然可以使用，没有停服 vercount则比较新，并做了一些代码优化 两种使用都基本一样，差别不大，看自己喜好，下面的教程是以vercount来举例，用不蒜子的话，就把对应的脚本和元素标签替换一下就好 1 基本引入 （1）修改layouts/partials/footer/custom.html（不存在则自行创建），引入脚本 1 2 \u0026lt;!-- vercount的脚本；若用不蒜子，则更换成不蒜子的脚本就好 --\u0026gt; \u0026lt;script defer src=\u0026#34;https://cn.vercount.one/js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）准备一张浏览量的icon(Ctrl+S保存)，放到assets/icons文件夹下 （3）修改layouts/article/components/details.html，在合适的位置下加入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 浏览量统计 --\u0026gt; \u0026lt;div id=\u0026#34;viewCount\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;eye\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; \u0026lt;!-- vercount统计当前页面浏览数的标签；若用不蒜子，更换成不蒜子对应的标签就好 --\u0026gt; \u0026lt;span id=\u0026#34;vercount_value_page_pv\u0026#34;\u0026gt;loading... \u0026lt;/span\u0026gt;次 \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; （4）这样文章详情的开头就显示浏览数了 2 问题修复 问题描述： 博客首页的文章列表显示了浏览数，且只有第一篇文章才有浏览数，并且浏览数的数字不正确 产生原因： layouts/partials/article/components/details.html此html文件也被用在了博客首页的文章列表，所以也触发了vercount读取当前页面的浏览数 因为读取的数据是当前页面的浏览数，也就是首页的浏览数，并非文章的浏览数，所以数据只加载一次，且不准确 解决思路： 由于vercount并未提供只查询文章浏览数的接口，只有一个文章浏览数+1，并且返回浏览数的接口，所以无法实现首页对每篇文章的浏览数的单独查询 既然无法实现首页展示每篇文章的单独浏览数，那就直接隐藏就好了，等点入文章才看到具体的浏览数 具体操作： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; function showHideView() { // 判断是否存在vercount标签 let viewCounts = document.querySelectorAll(\u0026#34;#viewCount\u0026#34;); if (viewCounts) { // 判断是否为文章页 let article = document.querySelector(\u0026#34;.article-page\u0026#34;); if (!article) { viewCounts.forEach(ele =\u0026gt; { ele.style.display = \u0026#39;none\u0026#39;; }); } } } showHideView(); \u0026lt;/script\u0026gt; 如果嫌麻烦，浏览数统计可以和更新时间一样，放到文章末尾就好，就不会显示到首页上了 具体修改layouts/partials/article/footer.html就好，看个人喜好吧 ","date":"2025-02-28T11:29:14+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/view-count/cover_hu13397988041983243305.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/view-count/","title":"【Hugo】博客文章浏览数统计"},{"content":" 前言：\n这是从 【Hugo】Aplayer + PJAX 引入音乐播放放器并实现音乐不中断功能 中单独摘出的内容，内容一模一样 单独开一篇新文章，用来更新引入PJAX带来的问题，就不更新在音乐播放器那篇文章上了 此教程是基于Stack-3.26.0，不确保其他版本是否生效，若不生效请自行阅读源码修复 1 引入PJAX （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的 【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象 （4）根据官方文档，在layouts/partials/footer/custom.html加入以下代码来引入PJAX 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n2 问题修复 2.1 文章样式修复 问题描述： 随便点进其中一篇文章，可以发现文章内容的样式丢失 产生原因： \u0026lt;body\u0026gt;标签中的class名缺失article-page，导致文章样式丢失 解决思路： 通过官方提供了数据预处理方法，来预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 具体步骤： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) } // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 2.2 主题切换修复 问题描述： 当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 产生原因： 阅读Stack主题源码assets/ts/colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 解决思路： 在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。 阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 具体步骤： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 2.3 文章搜索修复 问题描述： 使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 产生原因： 查看assets/ts/search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 解决思路： 把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来 由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 具体步骤： （1）修改assets/ts/search.tsx代码，封装方法并export 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } （2）修改assets/ts/main.ts，引入搜索初始化方法并调用 1 2 3 4 5 6 7 8 9 ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （3）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 2.4 搜索内容跳转修复 问题描述： 虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了 产生原因： 阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。 解决思路： 阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 具体步骤： （1）修改assets/ts/search.tsx，在动态渲染数据方法末尾让pjax重新解析文档 1 2 3 4 5 6 7 8 9 private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 2.5 文章评论修复 问题描述： 如果博客有开启评论功能的话，会发现评论的脚本不生效了 产生原因： pjax引入自动执行的脚本，不支持自行执行 解决思路： 由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理： 用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 具体步骤： （1）修改layouts/partials/footer/custom.html，把实际的评论参数填写进行下面模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 实例演示(Giscus评论)： （1）修改layouts/partials/comments/include.html，添加一个元素标识，方便判断文章是否开启了评论 1 2 3 4 {{ if .Site.Params.comments.enabled }} ... \u0026lt;div class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {{ end }} （2）找到Stack主题的giscus评论文件layouts/partials/comments/provider/giscus.html （3）按照上面给出的模板，结合giscus文件，在layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; {{- with .Site.Params.comments.giscus -}} \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; (function () { // 判断当前是否有文章评论标识 let comment = document.querySelector(\u0026#34;.comment\u0026#34;); if (!comment) { return } let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;src\u0026#39;, \u0026#39;https://giscus.app/client.js\u0026#39;); script.setAttribute(\u0026#39;data-repo\u0026#39;, \u0026#39;{{- .repo -}}\u0026#39;); // ...以此类推 script.async = true; // 寻找合适的元素，添加脚本进去(在页脚前将评论脚本插入) document.querySelector(\u0026#39;.site-footer\u0026#39;).before(script) })(document); \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; {{- end -}} 2.6 KaTeX修复 问题描述： 点进含有 数学公式(KaTeX) 的文章，里面的数学公式不能正常渲染出来 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n产生原因： 阅读源码layouts/partials/article/components/math.html，KaTeX渲染公式需要执行renderMathInElement，而PJAX的无刷新技术无法触发DOMContentLoaded的监听 解决思路： 将KaTeX渲染方法renderMathInElement封装为函数，交由PJAX加载结束后执行 具体操作： （1）修改layouts/partials/article/components/math.html，添加一个元素标签，便于判断文档是否使用了KaTeX 1 2 ... \u0026lt;div class=\u0026#34;math-katex\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; （2）layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;script\u0026gt; async function renderKaTeX() { // 判断当前页面是否有KateX let katex = document.querySelector(\u0026#34;.math-katex\u0026#34;); if (!katex) { return; } // 等待函数加载成功后，再执行渲染方法 while (typeof renderMathInElement !== \u0026#39;function\u0026#39;) { await delay(500); } // KaTeX渲染方法 renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); } /** * 同步延迟 */ function delay(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time) }) } document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { renderKaTeX(); }) \u0026lt;/script\u0026gt; 3 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度\n（2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2025-02-26T13:46:57+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/pjax/cover_hu15269159841050007592.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/pjax/","title":"【Hugo】PJAX实现无刷新加载页面"},{"content":" 1 写轮眼加载动画 这边先介绍如何引入本博客的加载动画，直接复制就能实现，适用于代码二次开发能力不强的用户 \u0026ldquo;授人以鱼不如授人以渔\u0026quot;，后面会教大家如何引入自己想要的加载动画 1.1 基本引入 将以下代码复制进layouts/partials/head/custom.html(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sharingon\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ring\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;circle\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .loading { position: fixed; display: flex; justify-content: center; align-items: center; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; zoom: 3.0; background-color: #f5f5fa; } .animated-stop { animation-play-state: paused !important; } .scaleAndFadeout { animation: scaleAndFadeOut 1.5s forwards; } /** 放大1.5倍，并渐变到透明 */ @keyframes scaleAndFadeOut { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } } /* From Uiverse.io by shadowfax29 */ .sharingon { position: relative; width: 6em; height: 6em; background-color: red; border: 6px solid black; animation: rot 1s ease-in-out infinite; } .ring { position: absolute; content: \u0026#34;\u0026#34;; left: 50%; top: 50%; width: 3.5em; height: 3.5em; border: 4px solid rgb(110, 13 ,13 ,0.5); transform: translate(-50%,-50%); } .sharingon, .ring, .to,.circle { border-radius: 50%; } .to,.circle { position: absolute; content: \u0026#34;\u0026#34;; width: 0.9em; height: 0.9em; background-color: black; } .to:nth-child(1) { top: -0.5em; left: 50%; transform: translate(-40%); } .to::before { content: \u0026#34;\u0026#34;; position: absolute; top: -0.5em; right: -0.2em; width: 1.1em; height: 0.9em; box-sizing: border-box; border-left: 16px solid black; border-radius: 100% 0 0; } .to:nth-child(2) { bottom: 0.5em; left: -0.35em; transform: rotate(-120deg); } .to:nth-child(3) { bottom: 0.5em; right: -0.35em; transform: rotate(120deg); } .circle { top: 50%; left: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 20px 1px; width: 1em; height: 1em; } @keyframes rot { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt;\tfunction initLoading() { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 本地页面加载速度快，可自行使用setTimeout()来进行延迟，体验加载动画效果 // 执行加载完成动画 loadFinish(); // 延迟1.5s，待加载完成动画执行结束 setTimeout(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; }, 1500) }); } function loadFinish() { // 暂停动画 let sharingon= document.querySelector(\u0026#34;.sharingon\u0026#34;); sharingon.classList.add(\u0026#34;animated-stop\u0026#34;) // 放大并渐变到透明 let loading = document.querySelector(\u0026#34;.loading\u0026#34;); loading.classList.add(\u0026#34;scaleAndFadeout\u0026#34;) } initLoading(); \u0026lt;/script\u0026gt; 1.2 动画首次加载 每次切换页面都播放一次加载动画，这种看个人喜欢。 我个人是不太喜欢的，我只希望第一次打开这页面的时候加载一下就好 1.2.1 PJAX 如果你博客引入了PJAX功能，基本是不会出现这情况了。因为页头页脚一般不是PJAX会刷新的地方，所以页面切换时不会重复执行加载动画脚本 想了解PJAX可以去查看【Hugo】PJAX实现无刷新加载页面 1.2.2 SessionStorage PJAX技术对大部分轻度用户来说还是有点困难的，可以用SessionStorage存储一下页面是否已经播放过加载动画了，播放过了就不重新播放一遍，来平替PJAX技术\n(1) 将display改为none，默认不显示加载动画\n1 2 3 4 5 6 \u0026lt;style\u0026gt; .loading { ... display: none; } \u0026lt;/style\u0026gt; (2) 修改initLoading方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; function initLoading() { const isFirstVisit = !sessionStorage.getItem(\u0026#39;visited\u0026#39;); if (isFirstVisit) { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); loading.style.display = \u0026#34;flex\u0026#34;; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 执行加载完成动画 loadFinish(); // 延迟1.5s，待加载完成动画执行结束 setTimeout(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; }, 1500) sessionStorage.setItem(\u0026#39;visited\u0026#39;, \u0026#39;true\u0026#39;); }); } } \u0026lt;/script\u0026gt; (3) 这样就只有首次进入此网站时才播放加载动画，页面关闭后重新进入才再次播放加载动画 2 自定义加载动画 2.1 基本引入 (1) 前往UIverse，寻找自己喜欢的加载动画 (2) 将加载动画的html，css分别复制到下面的模板，然后将模板内容复制到layouts/partials/head/custom.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .loading { position: fixed; display: flex; justify-content: center; align-items: center; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; background-color: #f5f5fa; } /* css内容 */ \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt;\tfunction initLoading() { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 本地页面加载速度快，可自行使用setTimeout()来进行延迟，体验加载动画效果 loading.style.display = \u0026#34;none\u0026#34;; }); } initLoading(); \u0026lt;/script\u0026gt; 这样就能实现最基本的加载动画效果 2.2 样式修改 因为每个人的加载动画都不一致，这边只分享一下可能会用到的css样式，实际情况还需自己自行适配 也可以参考上面的写轮眼动画的写法，来模仿写法 CSS样式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 可能会用到的CSS */ { /* 整体修改元素大小(大于1放大, 小于1缩小) */ zoom: 1.0; /* 开始动画播放 */ animation-play-state: running; /* 暂停动画播放 */ animation-play-state: paused; /* 元素居中(flex布局) */ display: flex; justify-content: center; align-items: center; /* 元素隐藏 */ display: none; /* 定义动画 */ @keyframes 动画名 { 0% {} 进度% {} 100% {} } /* 执行动画 */ animation: 动画名 时间; } CSS动画参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * CSS动画常用参数 */ { /* 不透明度 */ opacity: 1; /* 放大缩小 */ transform: scale(1); /* 旋转 */ transform: rotate(360deg); /* 平移(水平, 垂直) */ transform: translate(-100%, 0); } ","date":"2025-02-19T11:21:50+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/page-loading/cover_hu8681908609188190185.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/page-loading/","title":"【Hugo】博客引入页面加载动画"},{"content":" TODO: bilibili视频，不摸的话\n前言：\n用 live2d-widget 自带模型用腻了之后，想找一个自己喜欢的模型，就接触了moc3类型的模型。moc3类型是cubism新版模型的类型，而旧版模型的类型是moc模型 而live2d-widget并不支持moc3模型，只支持moc模型，所以寻找新的组件来适配moc3模型。找到了以下两个组件 oh-my-live2d 和 Live2dOnWeb ，但这两组件或多或少有自己的毛病，不及 live2d-widget 使用方便 于是个人基于 live2d-widget 框架，对moc3类型的模型进行适配，诞生了此项目 live2d-widget-v3 1 基本引入 （1）找到博客的页头(head)或页脚(footer)，将以下代码引入进去 tips: stack主题的页脚在layouts/partials/footer/custom.html，可以修改此html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;script\u0026gt; const cdnPath = \u0026#34;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#34;; const config = { // 资源路径 path: { homePath: \u0026#34;/\u0026#34;, modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // 工具栏 tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;photo\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // 模型拖拽 drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // 模型切换(order: 顺序切换，random: 随机切换) switchType: \u0026#34;order\u0026#34; } // 加载资源并初始化 if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // 异步加载资源 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; （2）这样就引入好了，模型是官方sdk自带的，模型的位置在仓库的/Resources目录下 2 自定义适配 2.1 调整css和提示语 （1）css样式调整和提示语的调整，跟live2d-widget无异，从仓库中下载waifu.css和waifu-tips.json文件，放入博客中，通过本地引入方式，修改代码中config.path.cssPath和config.path.tipsJsonPath这两个参数 （2）具体操作和调整方式，请参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.2 自定义模型 （1）自定义模型方式也是和live2d-widget基本无异(因为就是基于live2d-wdiget进行二开的)，准备好 model 和 model_list.json 文件，可直接下载本仓库代码中的/Resources目录 （2）将自己的自定义模型中放入model目录，修改 model_list.json 文件，最后修改config.path.modelPath通过cdn的形式引入文件 （3）具体操作参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.3 自定义模型-拓展 除了live2d-widget原生的功能外，个人还进行了一些功能拓展 接下来会以本站的模型，也是这位【b站up主】所提供的免费模型进行演示 如果你也使用此模型，请勿吝啬你的点赞、投币，收藏，来支持一下此up主 2.3.1 调整模型大小和位置 在模型的目录下，创建一个config.json文件，将以下内容复制进去，修改参数就可以对大小和位置进行调整 【在线调整地址】 scale: 模型大小 translate.x: 模型x轴偏移量 translate.y: 模型y轴偏移量 1 2 3 4 5 6 7 { \u0026#34;scale\u0026#34;: 1.0, \u0026#34;translate\u0026#34;: { \u0026#34;x\u0026#34;: 0.0, \u0026#34;y\u0026#34;: 0.0 } } 2.3.2 适配模型表情 模型文件中如果存在xxx.exp3.json文件，此文件为模型的表情文件 可修改xxx.model3.json，按照以下格式，进行配置 1 2 3 4 5 6 7 8 9 10 11 12 { ... \u0026#34;FileReferences\u0026#34;: { ..., \u0026#34;Expressions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;表情名\u0026#34;, \u0026#34;File\u0026#34;: \u0026#34;表情文件路径\u0026#34; } ] } } 这样点击侧边工具栏的标签按钮，就会随机切换表情了 2.3.3 适配模型动作 若模型存在xxx.motion3.json文件，此文件为模型的动作文件 可以修改xxx.model3.json文件，按照以下格式，进行配置 动作的触发分为两种，配置时选其中一种配置即可 Idel：闲置动作，会一直从闲置动作数组中，随机选一个进行播放 TapBody：点击动作，当点击画布时，才会从点击动作数组中，随机选一个进行播放 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { ... \u0026#34;FileReferences\u0026#34;: { ... \u0026#34;Motions\u0026#34;: { \u0026#34;Idle\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ], \u0026#34;TapBody\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ] } } } 因为我配置的是TapBody，所以点击模型时，会触发模型的招手动作 3 优化 3.1 png转webp 为了优化模型的加载速度，可以将模型中的皮肤png文件，转为webp文件【在线转换地址】 清晰度几乎没有变化，但皮肤文件的小了有10倍多，可以减少网络请求量，从而加快加载速度 转完webp文件后，修改xxx.model3.json文件，将皮肤文件从png改成webp 这样网络请求时要加载的数据量就会少很多 ","date":"2024-11-14T15:21:35+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/cover_hu11373105535066101579.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/","title":"【Hugo】博客引入moc3类型的live2d模型"},{"content":" TODO：bilibili视频，不摸的话\n1 修改背景图 (1) 准备一张背景图，尽可能大一点，并放到assets/background文件夹下(不存在则自己创建) (2) 在页脚文件layouts/partials/footer/custom.html中(不存在则自己创建)，引入以下代码，修改对应的背景图片名 不同的主题对应的页脚文件不同，按自己实际主题的页脚文件引入代码\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 2 引入动态背景 2.1 樱花飞舞 (1) 下载【sakura.js】(Ctrl + S 保存)，并放到assets/background文件夹下\n(2) 在layouts/partials/footer/custom.html中，引入以下代码\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 2.2 点线漂浮(particles.js) 【particles.js文档】\n(1) 前往【配置页面】配置参数，参数按自己喜好即可，唯一注意要修改的参数是 detect_on，要改成 window\n(2) 下载配置文件，以及 particles.js 所需要的js文件 【particlesjs-config.json】(Ctrl + S 保存)，本博客的动态背景json配置，有需求的可直接下载 (3) 把下载好的文件，解压并将以下两个文件放到assets/background文件夹下 particlesjs-config.json particles.min.js (4) 在layouts/partials/footer/custom.html中，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src={{ (resources.Get \u0026#34;background/particles.min.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; particlesJS.load(\u0026#39;particles-js\u0026#39;, {{ (resources.Get \u0026#34;background/particlesjs-config.json\u0026#34;).Permalink }}, function() { console.log(\u0026#39;particles.js loaded - callback\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #particles-js { position: fixed; top: 0; left: 0; width: 100%; z-index: -1; } \u0026lt;/style\u0026gt; ","date":"2024-10-12T15:59:49+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/cover_hu14760223960418122026.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/","title":"【Hugo】修改博客背景并引入动态背景"},{"content":" TODO：bilibili视频，可能做，可能不做，内容比较杂，不太好做视频\n1 修改字体 (1) 前往【100font】，下载自己想要的字体，这边演示缝合像素字体，字体文件为 fusion-pixel-10px-monospaced-zh_hans.ttf (2) 把字体文件放入assets/font下(文件夹自己创建) (3) 将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建) 字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; (4) 这样博客字体就修改好了 2 修改鼠标样式 (1) 准备好鼠标样式图片(默认，指针，文本\u0026hellip;)，图片大小建议控制在 32px 左右，将图片放入static/mouse文件夹下(文件夹自己创建) 演示鼠标来源：【B站up主】 (2) 修改assets/scss/custom.scss(文件不存在则自己创建)，将以下代码复制进去，根据主题按实际情况填写对应的css选择器 1 2 3 4 5 6 7 8 9 10 11 // 【鼠标样式常规写法】 body, html { cursor: url(../mouse/默认光标图片名), auto !important; } css选择器 { cursor: url(../mouse/其他光标图片名), auto; } (3) 以下是我调试好的 stack 主题的鼠标样式，同样是stack主题的可以直接复制，修改对应的图片名即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 【Stack主题鼠标样式写法】 // default光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 3 显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置 1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 修改github action文件.github/workflows/xxx.yaml，在运行 hugo -D 命令的step前加入以下配置 1 2 3 4 5 6 7 8 9 jobs: deploy: steps: - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false (3) 这样就提交代码时，就会去读取git时间，来更新文章的更新时间 stack主题的文章更新时间在文章底部 (4) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/details.html，在指定位置引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 tips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 4 友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 5 文章目录折叠\u0026amp;展开 (1) 将以下代码复制到layouts/partials/footer/custom.html文件中(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; (2) 这样文章就会默认隐藏子目录，等滚动到对应的目录后，才会将子目录进行展示 6 添加\u0026rsquo;返回顶部\u0026rsquo;按钮 (1) 准备一张返回顶部图片(Ctrl+S保存)，放到assets/icons文件夹下(不存在则自行创建) (2) 将以下代码复制到layouts/partials/footer/custom.html文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/backTop.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; (3) 这样当我们页面滚动到一定距离后，右下角会出现返回顶部的按钮，点击后可以平滑地返回顶部 7 macOS风格的代码块 (1) 准备一张macOS代码块的红绿灯图片(Ctrl+S保存), 放到static/icons文件夹下 (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; } .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(../icons/macOS-code-header.svg) no-repeat 0; background-size: contain; height: 18px; margin-top: -10px; margin-bottom: 10px; } 8 自定义MD引用块颜色模板 参考文章：让Hugo支持GitHub风格的块引用Alerts\n(1) 创建文件layouts/_default/_markup/render-blockquote-alert.html，并将以下代码复制进去\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 配色参考来源：martignoni/hugo-notice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-warn { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-error { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-warn { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-error { --card-separator-color: #880000; --blockquote-background-color: #450000; } } (3) 使用方法 可选项：NOTE | TIP | WARN | ERROR 可仿照上面css写法，自行添加新的css样式，来实现更多的可选项 1 2 \u0026gt; [!NOTE] \u0026gt; 这是markdown的引用块语法 (4) 效果演示 这是NOTE风格\n这是TIP风格\n这是WARN风格\n这是ERROR风格\n9 代码块过长折叠\u0026amp;展开 代码块折叠的样式风格完全仿照CSDN来实现的\n(1) 准备一张向下展开图片(Ctrl+S保存)，放到assets/icons目录下 (2) 将以下代码复制进layouts/partials/footer/custom.html(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; // 触发resize事件，重新计算目录位置 window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; ","date":"2024-10-08T11:10:25+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/cover_hu782432619297144394.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/","title":"【Hugo】Stack主题自定义修改"},{"content":" 1. 基础引入 【Live2d-widget文档】 （1）查看官方文档，引入对应的js脚本到layouts\\partials\\footer\\custom.html中(详情看引入音乐播放器的文章) 1 2 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）成功在左下角引入了live2d看板娘 2. 自定义适配 看板娘是已经引入好了，但是显示在左下角，跟我当前的主题非常的不搭，需要对看板娘进行自定义，来适配主题\n2.1 抽离autoload.js (1) 前往【Live2d-widget文档】，把 waifu-tips.json 和 waifu.css下载，并放到assets/waifu文件夹中(自己新建) (2) 把之前引入的 autoload.js 删掉，把下面代码引入到 custom.html 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; // 获取博客本地资源地址 const cssPath = {{ (resources.Get \u0026#34;waifu/waifu.css\u0026#34;).Permalink }} const tipsJsonPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.json\u0026#34;).Permalink }} // live2d_path 参数建议使用绝对路径 const live2d_path = \u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\u0026#34;; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(cssPath, \u0026#34;css\u0026#34;), loadExternalResource(live2d_path + \u0026#34;live2d.min.js\u0026#34;, \u0026#34;js\u0026#34;), loadExternalResource(live2d_path + \u0026#34;waifu-tips.js\u0026#34;, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { // 配置选项的具体用法见 README.md initWidget({ waifuPath: tipsJsonPath, cdnPath: \u0026#34;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\u0026#34;, tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;photo\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;] }); }); } \u0026lt;/script\u0026gt; 2.2 调整css样式 (1) 修改assets/waifu/waifu.css，将看板娘移动到右侧，更加适配Stack主题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 【waifu.css】 */ #waifu-toggle { ... /* left: 0; */ right: 0; /* margin-left: -100px; */ margin-right: -90px; /* writing-mode: vertical-rl; */ writing-mode: vertical-lr; } #waifu-toggle.waifu-toggle-active { /* margin-left: -50px; */ margin-right: -40px; } #waifu-toggle.waifu-toggle-active:hover { /* margin-left: -30px; */ margin-right: -20px; } #waifu { ... /* left: 0; */ right: 10px; } #waifu-tool { ... /* right: -10px; */ margin-left: 260px; } (2) 这样看板娘就成功移动到右下角了 2.3 调整看板娘提示语 (1) 修改assets/waifu/waifu-tips.json，修改里面的css选择器，来适配页面内容元素，这边以复制按钮为例\n(2) 查看复制按钮的元素，属性为class=\u0026quot;copyCodeButton\u0026quot;\n(3) 修改assets/waifu/waifu-tips.json，新增or修改对应的文本，修改对应的css选择器 (4) 这样当我们鼠标移动到对应的元素之后，看板娘就会有对应的提示语 2.4 自定义模型 2.4.1 引入cdn (1) 前往【live2d_api】，下载代码，这仓库中的文件就是 live2d-widget 的所使用的模型\n(2) 修改model_list.json文件，来添加or删除live2d模型（若有属于自己的live2d模型，请将模型放到model文件夹下）\n(3) 引入live2d文件可以本地引入(具体看音乐播放器文章)，这次演示用cdn的形式引入，cdn使用的是【jsDelivr】\n(4) cdn引入不需要php文件，将多余的php文件删掉，只保留 model 和 model_list.json\n(5) github新建一个公有(public)仓库，将代码上传到仓库上，打标签(Tags)并发布(Releases)一个版本 (6) 修改layouts/partials/footer/custom.html文件中的cdnPath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { initWidget({ ... // 有文件夹就在后面拼文件夹路径 cdnPath: \u0026#34;https://cdn.jsdelivr.net/gh/{用户名}/{仓库名}@{标签名}/\u0026#34;, ... }); }); } \u0026lt;/script\u0026gt; (7) 这样就成功通过cdn的形式引入自己的live2d模型文件 2.4.2 bug修复 如果你 model_list.json 中的 live2d模型分组 只有一组的时候，会存在bug，导致加载不出模型，需要进行修复\n(1) 前往【Live2d-widget】，下载 waifu-tips.js，并放到assets/waifu文件夹下，修改 custom.html 来引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const tipsJsPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (2) 修改 waifu-tips.js 文件，全局搜索e=1,o=53，将内容改为e=0,o=0，这两个值是默认模型和默认皮肤，所以一旦模型分组小于2的时候，就会找不到模型(代码顺序从0开始数) (3) 打开浏览器，按F12打开控制台，清理 localStorage(本地存储) 中的数据 (4) 这样加载模型默认加载第0个模型，bug就修复了 3 优化 3.1 多皮肤切换修复 （1）某些模型是具有多皮肤的(例如22, 33之类的)，但切换皮肤按钮不生效，是因为cdn形式引入是不适配皮肤切换的\n（2）这边对cdn引入方式的皮肤切换功能做了适配，下载我修改过的 live2d.min.js ，放到assets/waifu下，通过本地的形式引入\nlive2d.min.js（Ctrl+S保存） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const live2dJsPath = {{ (resources.Get \u0026#34;waifu/live2d.min.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;), ... ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (3) 这样就能切换这些看板娘的皮肤了 3.2 拖拽看板娘 (1) 有时候看板娘在右下角可能有点碍事，阻碍到我们点击一些页面内容，给看板娘添加拖拽功能，将她拖走\n(2) 将下面的代码复制进layouts\\partials\\footer\\custom.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { ... // 初始化看板娘鼠标监听事件 initWaifuMouseEvent(); }); } function initWaifuMouseEvent() { const waifu = document.getElementById(\u0026#34;waifu\u0026#34;); let isDown = false; let waifuLeft; let mouseLeft; let waifuTop; let mouseTop; // 鼠标点击监听 waifu.onmousedown = function (e) { isDown = true; // 记录x轴 waifuLeft = waifu.offsetLeft; mouseLeft = e.clientX; // 记录y轴 waifuTop = waifu.offsetTop; mouseTop = e.clientY; } // 鼠标移动监听 window.onmousemove = function (e) { if (!isDown) { return; } // x轴移动 let currentLeft = waifuLeft + (e.clientX - mouseLeft); if (currentLeft \u0026lt; 0) { currentLeft = 0; } else if (currentLeft \u0026gt; window.innerWidth - 300) { currentLeft = window.innerWidth - 300; } waifu.style.left = currentLeft + \u0026#34;px\u0026#34;; // y轴移动 let currentTop = waifuTop + (e.clientY - mouseTop); if (currentTop \u0026lt; 30) { currentTop = 30 } else if (currentTop \u0026gt; window.innerHeight - 290) { currentTop = window.innerHeight - 290 } waifu.style.top = currentTop + \u0026#34;px\u0026#34;; } // 鼠标点击松开监听 window.onmouseup = function (e) { isDown = false; } } \u0026lt;/script\u0026gt; (3) 这样就可以随意拖拽看板娘了（如果是没有腿的模型，建议把y轴移动的代码注释掉） ","date":"2024-09-19T17:17:34+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/cover_hu3013000311457165536.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/","title":"【Hugo】Live2d-widget 给博客引入萌萌的看板娘"},{"content":" 1 引入音乐播放器 【Aplayer官方文档】\n（1）在博客主目录中创建文件layouts\\partials\\footer\\custom.html，此文件为Stack主题作者留给我们加入自定义组件用的文件(可以查看主题源码同路径文件找到) （2）查看官方文档，引入对应的脚本，css到custom.html中，页面最下面就会出现音乐播放器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; （3）修改 ap对象 配置，改成吸底模式 1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); （4）填写 audio 数组，引入歌曲，封面和歌词 lrcType 的值具体看【文档】 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const staticDir = {{ .Site.Home.Permalink }} const ap = new APlayer({ ..., lrcType: 3, audio: [ { name: \u0026#39;name\u0026#39;, // 歌名 artist: \u0026#39;artist\u0026#39;, // 歌手 url: \u0026#39;url.mp3\u0026#39;, // 歌曲路径 cover: \u0026#39;cover.jpg\u0026#39;, // 封面路径 lrc: \u0026#39;lrc.lrc\u0026#39;, // 歌词路径 }, { // 本地路径引入写法（有子目录就在staticDir后面继续拼接） name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: staticDir + \u0026#39;url.mp3\u0026#39;, cover: staticDir + \u0026#39;cover.jpg\u0026#39;, lrc: staticDir + \u0026#39;lrc.lrc\u0026#39;, } ] }); 到这一步音乐播放器已经引入完了\n2 音乐播放器样式切换 （1）通过阅读Stack主题的源码可以看到，主题样式的切换是通过[data-scheme=\u0026quot;light/darck\u0026quot;] {...}\n（2）所以我们可以准备两种Aplayer的css，用[data-scheme=\u0026quot;light\u0026quot;]{ 亮的css样式 }包裹亮的，用[data-scheme=\u0026quot;dark\u0026quot;]{ 暗的css样式 }包裹暗的，这里直接给各位准备好了\naplayer-light.scss（Ctrl+S保存） aplayer-dark.scss（Ctrl+S保存） （3）在博客主目录中创建文件assets\\scss\\custom.scss，此文件为Stack主题作者留给我们加入自定义样式用的文件(可以查看主题源码同路径文件找到) （4）将上述两个scss文件放到跟 custom.scss同目录下，并通过@import来进行引入文件\n1 2 3 4 5 /** * 【custom.scss】 */ @import \u0026#34;aplayer-light.scss\u0026#34;; @import \u0026#34;aplayer-dark.scss\u0026#34;; （5）因为音乐播放器的css改为我们本地文件引入了，所以 custom.html 中的link标签可以将它注释掉或者删掉了 1 2 3 \u0026lt;!-- custom.html --\u0026gt; ... \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; --\u0026gt; 到这一步样式随主题切换已经完成了\n3 音乐播放进度保留 （1）实现思路：页面切换前，把歌曲的 歌曲序号，播放时长，播放状态 记录下来；在页面切换加载完之后，我们调用Aplayer的接口切换歌曲，调整时长，并选择播放or暂停\n（2）通过console.log(ap)打印ap对象，或者官方文档，可以找到我们需要的参数\nlist.index：歌曲序号 audio.currentTime：播放时长 paused ：播放状态（是否暂停） （3）通过【官方文档】可以查找到我们需要调用的接口\nap.list.switch(index: number)：切换歌曲 ap.seek(time: number)：调整时长 ap.play()：播放歌曲 （4）需要的东西已经找齐，只需在 custom.html 加入以下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... /** * 页面销毁前监听 */ window.onbeforeunload = () =\u0026gt; { // 将播放信息用对象封装，并存入到localStorage中 const playInfo = { index: ap.list.index, currentTime: ap.audio.currentTime, paused: ap.paused }; localStorage.setItem(\u0026#34;playInfo\u0026#34;, JSON.stringify(playInfo)); }; /** * 页面加载后监听 */ window.onload = () =\u0026gt; { // 从localStorage取出播放信息 const playInfo = JSON.parse(localStorage.getItem(\u0026#34;playInfo\u0026#34;)); if (!playInfo) { return; } // 切换歌曲 ap.list.switch(playInfo.index); // 等待500ms再执行下一步(切换歌曲需要点时间，不能立马调歌曲进度条) setTimeout(() =\u0026gt; { // 调整时长 ap.seek(playInfo.currentTime); // 是否播放 if (!playInfo.paused) { ap.play() } }, 500); }; \u0026lt;/script\u0026gt; 到这一步音乐播放进行已经完成了\n4 引入PJAX PJAX已单独创建到一篇新的文章上 【Hugo】PJAX实现无刷新加载页面 后续相关问题将在新文章中更新，不会在此文章进行更新 ⚠️建议直接看新文章来引入PJAX 4.1 基本引入 （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的\n【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象 （4）根据官方文档，在 custom.html 加入以下代码来引入PJAX\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n4.2 文章样式修复 （1）随便点进其中一篇文章，可以发现文章内容的样式丢失，缺少文章该有的边框 （2）通过手动刷新，对比页面元素发现，决定文章样式的是\u0026lt;body\u0026gt; 标签中的class名: article-page，存在此class名就会识别到文章该有的css （3）因为\u0026lt;body\u0026gt;内包含整个页面的所有内容，包括我们的音乐播放器，所以不能让PJAX监听\u0026lt;body\u0026gt;标签\n阅读官方文档发现，官方提供了数据预处理方法，让我们处理数据 我们通过预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 这样我们切页面后，都会自动把body中的className更新，就不会丢失样式了\n4.3 主题切换修复 （1）当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 （2）阅读Stack主题源码\\assets\\ts\\colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 （3）解决思路：在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。\n阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 这样元素的点击事件重新绑定，主题颜色就能正常切换了\n4.4 文章搜索修复 （1）使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 （2）查看layouts\\ts\\search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 （3）解决思路类似上面的，把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来，由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 - （以下操作请复制同路径同名文件到自己主目录下修改，不要在主题源码中修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 【search.tsx】 * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【main.ts】 */ ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （4）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 这样search.tsx能正常初始化，文章搜索功能恢复\n4.5 搜索内容跳转修复 （1）虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了\n（2）阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【search.tsx】 */ private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 这样动态渲染出的页面数据就能被PJAX识别到，就不会刷新页面跳转了\n4.6 文章评论修复 （1）如果博客有开启评论功能的话，会发现评论的脚本不生效了\n（2）由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理：\n用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- custom.thml --\u0026gt; ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 这样PJAX会自动加载我们的评论脚本\n5 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度\n（2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2024-08-14T14:50:54+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/cover_hu6146897835255991630.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/","title":"【Hugo】APlayer + PJAX 引入音乐播放放器并实现音乐不中断功能"},{"content":" 1 环境准备 1.1 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可 1.2 Hugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip 2 搭建博客 2.1 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行 （2）敲打命令hugo new site xxxx创建hugo文件 （3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中 （4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 2.2 配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载 （2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content （4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 （5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章 3 Github部署 3.1 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 3.2 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件\n（2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main ","date":"2024-07-22T15:44:59+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/%E5%B0%81%E9%9D%A2_hu14931377072575281322.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/","title":"【Hugo】Hugo + Github 免费部署自己的博客"}]