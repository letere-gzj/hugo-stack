[{"content":" 前言：\n最近一直在研究文本转语音（TTS: Text To Speech）技术，接触到了fish-speech，但fish-speech情感控制不是很好用 刚好最近B站开源的indexTTS出了2，尝试一下 【indexTTS官网】 【indexTTS项目】 【indexTTS2效果演示】 【indexTTS2在线体验】 1 体验分享 在声音的还原度上，indexTTS2相当的好，第一次去去它的演示网站去使用时，我都惊呆了，竟然会这么还原，效果比fish-speech真的要好\n而且indexTTS2有丰富的感情控制参数调整，发音感情调整起来真的方便非常多，而且效果很不错，这算是indexTTS2非常大的一个优点\nindexTTS2效果好的代价就是推理的速度真的慢，跟fish-speech比真的要慢多了，即使时使用CUDA加速的情况下，还是慢，对电脑的性能要求较高\n而且有些功能上没fish-speech好用，就例如fish-speech的发音调整，我觉得是一个很好用的功能，可惜indexTTS2没有\n总结： indexTTS2并不是完全意义上的fish-speech的上位替代，算是各有春秋，但使用体验上，应该是indexTTS2更胜一筹\n2 效果演示分享 因为indexTTS2最大的特点就是丰富的情感控制，这边也着重去演示语音情感 下面以鸣潮-今汐的音频来演示 文本 音频 一个人走虽然更快，一群人才能走得更远。未来的路，我会和大家，会和你一起走下去。 2.1 与音色参考音频相同 音色参考音频的情感是怎样的，生成音频情感也是怎样的 你和钱，对我都不重要。没有你，对我很重要。 音色参考音频 生成音频 2.2 使用情感参考音频 在音色音频的基础上，额外再上传一个情感参考音频，来生成对应音色对应情感的音频 你给我翻译翻译，什么他妈的是他妈的惊喜 情感 情感参考音频 生成音频 生气 伤心 2.3 使用情感向量控制 可以调整下方的情况变量来实现自己想要的效果，可以组合使用 酒要一口一口喝，步要一步一步走，步子迈大了，容易扯着蛋 情感向量 生成音频 喜 0.6 哀 0.6 2.4 使用情感描述文本控制 可以文字输入描述情感的文本来控制（实际体验下来不是很好用，容易情绪占比过重导致音色发生改变） 你带着老婆，出了城，吃着火锅还唱着歌，突然就被麻匪劫了 情感描述文本 生成音频 非常生气 非常伤心 ","date":"2025-09-12T15:11:05+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/ai/indextts/try-report/cover_hu16781913785467096121.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/ai/indextts/try-report/","title":"【AI】B站开源IndexTTS2使用体验报告"},{"content":" 1 环境准备 1.1 conda安装 conda官网 conda官方文档 （1）下载conda，conda有多个版本，具体版本可以按需下载，这边演示下载miniconda （2）下载后，除了安装路径按需选择外，其余一路默认安装即可\n（3）添加conda环境变量\n（4）命令行敲conda -V，成功显示版本则安装成功 2 本地部署 fish-speech项目 fish-speech部署文档 以下内容根据官方文件进行编写，若内容失效，请根据官方最新文档进行部署 2.1 安装 （1）下载fish-speech项目 （2）安装fish-speech（以conda形式），在解压的fish-speech项目文件夹敲一下命令 1 2 3 4 conda create -n fish-speech python=3.12 conda activate fish-speech pip install -e . 2.2 推理 （1）前往huggingface官网获取fish-speech模型的访问权限 模型可能会更新，具体最新模型看官方文档 （2）创建fish-speech的访问令牌 （3）命令行敲huggingface-cli login，设置访问令牌 （4）命令行下载模型 huggingface-cli download fishaudio/openaudio-s1-mini --local-dir checkpoints/openaudio-s1-mini （5）运行fish-speech fish-speech运行有多种方式，这边推荐使用webui，界面简洁清晰，敲python -m tools.run_webui运行 3 推理加速 启动fish-speech会看到一个CUDA is not available, running on CPU.，因为运行在CPU，所以速度比较慢，因此我们需要安装一下CUDA\n3.1 CUDA安装 （1）前往控制面板，检查CUDA是否已安装（已安装可跳过本内容） （2）打开 NVIDIA Control Panel(英伟达控制面板) 的系统设置，查看支持的CUDA版本 这边支持的是13.0.84之前的版本 （3）前往英伟达官网下载适合自己电脑版本的CUDA （4）安装一律默认即可 （5）安装完成后，命令行敲击nvcc -V，检查是否安装成功 3.2 更换pytorch版本 （1）前往pytorch官网，查看适合自己cuda版本的pytorch，并敲对应的命令下载，更换版本 4 fish-speech使用 4.1 基础使用 （1）准备好一段音频，以及文本（下面以星穹铁道-三月七为例） 文本 音频 照片当然不是现实，但如果有足够多的照片，是不是就能更接近现实一些呢？ （2）上传参考音频，填写参考文本 （3）输入想要的转换的文本，并点击生成 文本 音频 你好啊，我是三月七，这是我用fish-speech生成的语音，你觉得声音像吗？ 4.2 references使用 （1）在fish-speech主文件夹下创建references文件夹 （2）在references文件夹下创建音频文件夹，并把对应的音频，以及文本放入 文本以.lab文件名存储 （3）在webui的Reference ID中填入对应的音频文件夹名，则可自动导入音频和文本，不用再次上传和填写了 4.3 发音调整 （1）以下面的文本为例 文本 音频 你成功说服了我 （2）其中的说的发音是shui4，如果调整为shuo1，可以用\u0026lt;|phoneme_start|\u0026gt;拼音\u0026lt;|phoneme_end|\u0026gt;来处理 文本 音频 你成功\u003c|phoneme_start|\u003eshuo1\u003c|phoneme_end|\u003e服了我 4.4 情感语调调整 可以在话语前，添加（标识）来控制这段话的情感or语调，具体可看官方文档 自己实际使用下来感觉效果不是很明显 文本 音频 你竟然敢背叛我！我对你这么信任，你就是这样回报我的吗？ （愤怒）你竟然敢背叛我！（语气激动）我对你这么信任，（大声）你就是这样回报我的吗？ ","date":"2025-09-01T17:00:27+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/ai/fish-speech/deploy/cover_hu11095128414292951226.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/ai/fish-speech/deploy/","title":"【AI】fish-speech文本转语音项目本地部署"},{"content":" 1 广场工会区 2 居民区 3 过道 4 自然区 5 地图 ","date":"2025-06-28T10:46:08+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/game/fli/build-share/cover_hu164004380255149663.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/game/fli/build-share/","title":"【FLI】幻想生活i岛建记录分享"},{"content":" 前言：\n汉化补丁来源：B站Up主-清羽510 汉化教程原文：【STEAM】噬神者1+2卡加载以及汉化补丁安装教程（包含steamdeck） 本文只是个人汉化过程的一个记录，仅自用 1 汉化 （1）下载汉化补丁，将part1~12全都下载 百度网盘(提取码：GERB) 天翼云盘(访问码：2yfr) 如果链接失效，请联系制作汉化补丁的up主 补丁包含日语资源，所以比较大，steam版只有英语(日本二次元游戏，还是日语对味点) （2）解压(密码：qingyu510) 汉化补丁是分卷压缩，用windows默认的解压软件无法解压，可以下载7-Zip来解压 全选所有压缩文件，鼠标右键选择提取，即可解压 如果密码错误，请联系制作汉化补丁的up主 （3）将解压的内容全部复制到游戏文件夹中 steam可以直接设置 -\u0026gt; 管理 -\u0026gt; 浏览本地文件来打开游戏文件夹 （4）汉化已经打好，启动游戏即可 如果遇到问题，可以看看制作汉化补丁的up主的教程，看有没有你遇到的情况，本人是没遇到任何问题 2 问题修复 如果你跟我一样是使用PS手柄的话，进入游戏会发现游戏的按键图标非常的奇怪，变成数字 可以开启steam的控制器映射，这样就可以将PS手柄映射成Xbox手柄，图标就会变成Xbox图标，虽然不是PS图标，但总比不知道什么按键的数字要好 3 补丁缺陷 这补丁有个小问题就是游戏资料库中的教程说明不显示按键图标，导致不知道武器的技能要怎么按出来，其实问题也不大，上网搜一搜就好了 我玩这么久了也就是这么一个问题，总之非常感谢大佬的汉化补丁制作 ","date":"2025-06-17T10:26:00+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/game/ge2rb-chinese/cover_hu12754726281147492124.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/game/ge2rb-chinese/","title":"【GE2RB】噬神者2狂怒解放steam版汉化"},{"content":" 前言：\nAI技术迅速发展，各种新技术层出不重，作为开发者应主动了解这些技术，以免被市场淘汰 MCP算是AI辅助代码开发中比较重要的一项技术 1 MCP介绍 MCP官方文档 MCP：Model Context Protocol(模型上下文协议)是一个开放协议，它为应用程序向 LLM 提供上下文的方式进行了标准化。你可以将 MCP 想象成 AI 应用程序的 USB-C 接口。就像 USB-C 为设备连接各种外设和配件提供了标准化的方式一样，MCP 为 AI 模型连接各种数据源和工具提供了标准化的接口。 简单来说MCP是一个统一规范的协议，遵循这个协议来开发的MCP服务，是给AI使用的工具，来拓展AI的功能\n类比： AI = 电脑 MCP = 电脑的USB插口 MCP服务 = 鼠标，键盘等外设 2 MCP使用 2.1 使用场景准备 (1) MCP与AI挂钩，所以要使用MCP，肯定要准备AI代码编程相关的软件或插件 AI编程软件首推Cursor，但是收费软件(有破解途径就是了) 因为我是Java开发，更习惯IDEA的界面，所以选择了AI编程插件通义灵码(主要是免费，不用搞破解) 非代码开发者的话，可以选择使用Cherry studio，算是给非开发者使用的一个AI对话软件 (2) 一般AI只有问答对话功能，没法实现其他更多的功能 例如我让AI帮我实现下面的需求 1 2 1. 帮我编写一个\u0026#34;翻页时钟\u0026#34;的html页面，时钟的时间以读取本地时间为主 2. 将生成好的html保存到当前目录下，文件名为\u0026#34;flip-clock.html\u0026#34;，并将文件路径输出到控制台 (3) 可以看到，AI无法实现文件保存功能，所以需要一个MCP服务，来拓展AI的功能 2.2 MCP服务搭建 MCP服务搜索网址推荐：\npunkpeye/awesome-mcp-servers modelcontextprotocol/servers Smithery mcp.so ModelScope (1) 根据上面的需求，需要一个能操作本地系统文件的MCP服务，这边选择的是Filesystem 要使用MCP服务需搭建好对应的环境 以NPX运行的，需要先安装Node.js环境(教程需自己寻找)，FileSystem就是npx运行的 以UVX运行的，需要先安装Python环境(可看【Python】Windows搭建Python环境)，搭建完后运行pip install uv就好 (2) 通义灵码点击MCP工具，通过MCP广场搜索文件，最后点击安装 也可以通过配置文件添加，将上面的npx脚本复制进去就好 (3) 默认安装会失败，错误信息是没有对应的文件或文件夹，因为里面的参数是默认参数，需按实际情况修改 (4) 按实际情况修改自己电脑的用户名，以及后面的允许操作的文件夹路径 我图省事，将整个D盘都设置为允许操作 (5) 无报错信息即搭建成功 2.3 MCP服务使用测试 (1) AI模式切换成智能体，然后重新运行一次上面的需求 (2) 运行期间会询问是否执行MCP工具，点击允许就好 (3) AI成功通过MCP服务，实现了将代码保存为文件的功能 下面是AI帮我写的翻页时钟功能(Ctrl+S保存，修改后缀名为html即可) ","date":"2025-05-16T09:23:21+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/ai/mcp-learn/cover_hu6439481095123875832.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/ai/mcp-learn/","title":"【AI】MCP初认识"},{"content":" 前言：\n个人喜好问题，软件的安装不喜欢用exe安装，更喜欢用压缩包形式进行安装，这样方便管理，也方便卸载 所以下面的python也是以压缩包形式进行搭建，也就是免安装或绿色版 1 Python安装 (1) 前往Python官网，选择要下载的版本，点击对应的download (2) 点击下载对应电脑位数的Windows embeddable package包 (3) 下载完后直接解压 (4) 配置环境变量 此电脑 -\u0026gt; 鼠标右键 -\u0026gt; 属性 -\u0026gt; 高级系统设置 -\u0026gt; 环境变量 将python文件夹路径加入到path中 (5) 打开命令行，输入python -V，正常显示版本号则安装成功 2 Pip安装 pip是Python官方提供的包管理工具，用于安装Python第三方库， pip安装包后，可以不用再下载安装包，直接使用命令行安装，方便管理，也方便卸载 所以搭建python环境基本都要安装pip (1) 前往Pypi，下载get-pip.py文件(Ctrl+S保存) 上方标签可查看支持的python版本 (2) 下载后放入python文件夹，打开命令行运行python get-pip.py安装 (3) 修改python312._pth，将import site的注释去掉，允许Python加载site-packages目录 不同版本文件名中的数字不一致，按自己实际情况修改对应的pth文件 (4) 将安装pip产生的Scripts文件夹加入到环境变量中(参考python安装) (5) 打开命令行输入pip -V，正常显示版本号则安装成功 3 修改Pip镜像源 默认安装的pip使用的是Pypi官方源，速度很慢 为了保证下载速度，推荐将镜像源修改为国内镜像源 这边推荐的镜像源为阿里云(https://mirrors.aliyun.com/pypi/simple/) 运行命令pip config set global.index-url 镜像源地址 会自动在C:\\Users\\用户名\\AppData\\Roaming\\pip创建配置文件pip.ini ","date":"2025-05-14T14:08:02+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/python/build-env/cover_hu8776805525478338299.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/python/build-env/","title":"【Python】Windows搭建Python环境"},{"content":" 1 实现方法 (1) 创建layouts/partials/widget/xxx.html文件，文件名随意\n(2) 按照以下的模板，把对应的html，script，css代码复制进去\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div\u0026gt; \u0026lt;!--html内容--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // script内容 \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; /* css样式 */ \u0026lt;/style\u0026gt; (3) 修改hugo.yaml文件，在params.widgets中添加对应widget的名称 2 示例 2.1 时钟组件 时钟组件: letere-gzj/pure-css3-clock 演示地址 (1) 创建layouts/partials/widget/clock.html文件 (2) 按照实现方法中给出的模板，把html，script，css复制进去 html内容位置: pure-css3-clock/index.html script内容位置: pure-css3-clock/index.html css样式位置: pure-css3-clock/css/style.css (3) 修改hugo.yaml文件，在params.widgets中添加clock (4) 项目启动后，样式不太对，需对样式进行二次调整，来适配主题 (4) 修改css样式，将对应的样式进行注释(删除)和添加 tips: 没演示到的样式不要乱动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 .clock-wrapper { /* position: absolute; */ /* top: 0; */ /* left: 0; */ /* width: 100%; */ /* height: 100%; */ /* background-color: #eceef0; */ position: relative; width: 460px; height: 460px; zoom: 0.4; ... } .clock-border { /* top: 60px; */ /* bottom: 0; */ /* left: 0; */ /* right: 0; */ ... } (5) 刷新项目，样式正常，时钟组件引入成功 这是我改好的clock.html，可以直接下载使用(Ctrl+S保存)，下载后将后缀名改回html即可 ","date":"2025-05-06T17:46:24+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-widget/cover_hu13046901138449528525.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-widget/","title":"【Hugo】Stack主题使用自定义widget"},{"content":" 前言：\n官方文档：ShardingSphere 本篇文章基于5.5.2版本所编写，其他版本可能存在差异 1 数据准备 （1）表sql 1 2 3 4 5 6 CREATE TABLE `t_user` ( `user_id` bigint NOT NULL COMMENT \u0026#39;用户id\u0026#39;, `username` varchar(50) NULL COMMENT \u0026#39;用户名\u0026#39;, `sex` tinyint(1) NULL COMMENT \u0026#39;性别\u0026#39;, PRIMARY KEY (`user_id`) ); （2）数据库表结构 1 2 3 4 5 6 7 8 9 10 - sharding - 任意表 - sharding_0 - t_user_0 - t_user_1 - sharding_1 - t_user_0 - t_user_1 （3）按照上面的sql，以及数据库表结构，创建好数据库和表 2 ShardingSphere-JDBC 2.1 基本引入 （1）依赖引入 1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/org.apache.shardingsphere/shardingsphere-jdbc --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shardingsphere\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shardingsphere-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; （2）创建shardingsphere配置文件shardingsphere-config.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # 数据源配置 dataSources: default_ds: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding?serverTimezone=GMT%2B8 username: letere password: 123456 ds_0: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding_0?serverTimezone=GMT%2B8 username: letere password: 123456 ds_1: dataSourceClassName: com.zaxxer.hikari.HikariDataSource driverClassName: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://127.0.0.1:3306/sharding_1?serverTimezone=GMT%2B8 username: letere password: 123456 # 规则配置 rules: # 单表配置(不分库分表的表) - !SINGLE tables: - \u0026#34;default_ds.*\u0026#34; # 广播表配置(分库分表的表) - !BROADCAST tables: - \u0026#34;ds_0.t_user\u0026#34; - \u0026#34;ds_1.t_user\u0026#34; - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 库分片策略 databaseStrategy: standard: shardingColumn: user_id shardingAlgorithmName: user_database_inline # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_table_inline bindingTables: - t_user # 分片算法定义 shardingAlgorithms: user_database_inline: type: INLINE props: algorithm-expression: ds_${user_id % 2} user_table_inline: type: INLINE props: algorithm-expression: t_user_${sex % 2} # sql打印调试 props: sql-show: true （3）application.yaml引入shardingsphere配置文件 1 2 3 4 spring: datasource: driver-class-name: org.apache.shardingsphere.driver.ShardingSphereDriver url: jdbc:shardingsphere:classpath:shardingsphere-config.yaml （4）以上就成功引入实现了分库分表，对t_user进行新增操作，会触发分库分表策略，对于其他不分库分表的表就，直接在default_ds进行数据操作 2.2 自定义分片算法类 （1）实现ShardingAlgorithm的子接口，实现分片算法，下边以StandardShardingAlgorithm举例 StandardShardingAlgorithm ComplexKeysShardingAlgorithm HintShardingAlgorithm （2）创建自定义类，实现里面的方法 collection：分片表名集合 preciseShardingValue：分片字段值 rangeShardingValue：分片字段范围值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class CustomStandardShardingAlgorithm implements StandardShardingAlgorithm\u0026lt;Integer\u0026gt; { @Override public String doSharding(Collection\u0026lt;String\u0026gt; collection, PreciseShardingValue\u0026lt;Integer\u0026gt; preciseShardingValue) { // TODO: 分表业务处理（按自己实际业务修改） int tableNo = preciseShardingValue.getValue() % 2; // 返回对应的表名(表名_no) return preciseShardingValue.getLogicTableName() + \u0026#34;_\u0026#34; + tableNo; } @Override public Collection\u0026lt;String\u0026gt; doSharding(Collection\u0026lt;String\u0026gt; collection, RangeShardingValue\u0026lt;Integer\u0026gt; rangeShardingValue) { // TODO: 范围查询分表业务处理，一般用时间来分表的会使用到（按自己实际业务修改） // 返回对应表名集合 return collection; } } （3）在shardingsphere-config.yaml中，配置自定义分片算法类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 rules: - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_custom_standard # 分片算法定义 shardingAlgorithms: user_custom_standard: type: CLASS_BASED props: strategy: STANDARD algorithmClassName: com.xxxx.CustomStandardShardingAlgorithm 3 ShardingSphere-Proxy 下面ShardingSphere-Proxy的安装使用，是以windows版为主\n3.1 基本引入 （1）前往shardingsphere，下载shardingsphere-proxy二进制包 （2）命令行输入tar -zxvf apache-shardingsphere-5.5.2-shardingsphere-proxy-bin.tar.gz进行解压（包名，版本号按实际情况填写）\n（3）创建ex-lib文件夹，下载mysql驱动，并放入\n（4）修改conf/global.yaml，配置权限和属性 1 2 3 4 5 6 7 8 9 10 11 12 # 权限验证 authority: users: - user: root@% password: root admin: true privilege: type: ALL_PERMITTED props: # sql打印 sql-show: true （5）修改conf/database-sharding.yaml，配置数据源和分片规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 数据库名 databaseName: sharding_db # 数据源 dataSources: default_ds: url: jdbc:mysql://127.0.0.1:3306/sharding?serverTimezone=GMT%2B8 username: letere password: 123456 ds_0: url: jdbc:mysql://127.0.0.1:3306/sharding_0?serverTimezone=GMT%2B8 username: letere password: 123456 ds_1: url: jdbc:mysql://127.0.0.1:3306/sharding_1?serverTimezone=GMT%2B8 username: letere password: 123456 # 规则配置 rules: # 单表配置(不分库分表的表) - !SINGLE tables: - \u0026#34;default_ds.*\u0026#34; # 广播表配置(分库分表的表) - !BROADCAST tables: - \u0026#34;ds_0.t_user\u0026#34; - \u0026#34;ds_1.t_user\u0026#34; - !SHARDING # 表分片配置 tables: t_user: actualDataNodes: ds_${0..1}.t_user_${0..1} # 库分片策略 databaseStrategy: standard: shardingColumn: user_id shardingAlgorithmName: user_database_inline # 表分片策略 tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: user_table_inline bindingTables: - t_user # 分片算法定义 shardingAlgorithms: user_database_inline: type: INLINE props: algorithm-expression: ds_${user_id % 2} user_table_inline: type: INLINE props: algorithm-expression: t_user_${sex % 2} （6）运行bin/start.bat，命令行没终止即启动成功，默认端口3307，可以前往logs/stdout.log查看具体启动日志 3.2 连接使用 （1）可以通过原生mysql命令行，进行连接 运行命令mysql -P3307 -uroot -proot （2）用springboot连接的话，就将数据源配置为shardingsphere-proxy服务就好 1 2 3 4 5 spring: datasource: url: \u0026#39;jdbc:mysql://127.0.0.1:3307/sharding_db?serverTimezone=GMT%2B8\u0026#39; username: root password: root 3.3 自定义分片算法类 3.3.1 自定义算法类打包 （1）创建标准的maven目录结构，用于打包 1 2 3 4 5 6 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ └── resources/ └── pom.xml （2）创建自定义算法类(具体看shardingsphere-jdbc)，并放入上面的maven项目中 1 2 3 4 5 6 7 8 9 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ │ └── com/ │ │ └── example/ │ │ └── CustomShardingAlgorithm.java │ └── resources/ └── pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package com.example; import org.apache.shardingsphere.sharding.api.sharding.standard.PreciseShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.RangeShardingValue; import org.apache.shardingsphere.sharding.api.sharding.standard.StandardShardingAlgorithm; import java.util.Collection; public class CustomShardingAlgorithm implements StandardShardingAlgorithm\u0026lt;Integer\u0026gt; { @Override public String doSharding(Collection\u0026lt;String\u0026gt; collection, PreciseShardingValue\u0026lt;Integer\u0026gt; preciseShardingValue) { // TODO: 分表业务处理（按自己实际业务修改） int tableNo = preciseShardingValue.getValue() % 2; // 返回对应的表名(表名_no) return preciseShardingValue.getLogicTableName() + \u0026#34;_\u0026#34; + tableNo; } @Override public Collection\u0026lt;String\u0026gt; doSharding(Collection\u0026lt;String\u0026gt; collection, RangeShardingValue\u0026lt;Integer\u0026gt; rangeShardingValue) { // TODO: 范围查询分表业务处理，一般用时间来分表的会使用到（按自己实际业务修改） // 返回对应表名集合 return collection; } } （3）在resources目录下创建META-INF/services/org.apache.shardingsphere.sharding.spi.ShardingAlgorithm文件，并填写上面自定义算法类的全限定名 全限定类名：com.example.CustomShardingAlgorithm 1 2 3 4 5 6 7 8 9 10 11 12 my-sharding-algorithm/ ├── src/ │ └── main/ │ ├── java/ │ │ └── com/ │ │ └── example/ │ │ └── CustomShardingAlgorithm.java │ └── resources/ │ └── META-INF/ │ └── services/ │ └── org.apache.shardingsphere.sharding.spi.ShardingAlgorithm └── pom.xml （4）修改pom.xml，配置打包需要的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;project\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;my-sharding-algorithm\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- ShardingSphere依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shardingsphere\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shardingsphere-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- java版本，看情况修改 --\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;utf8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-assembly-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; （5）执行mvn clean package命令，用maven进行打包，生成的jar包在target文件夹下 3.3.2 proxy配置自定义分片算法类 （1）将上面打包好的jar包复制到ext-lib文件夹下\n（2）修改conf/database-sharding.yaml，配置自定义算法类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 规则配置 rules: - !SHARDING # 表分片配置 tables: t_user: tableStrategy: standard: shardingColumn: sex shardingAlgorithmName: custom_inline # 分片算法定义 shardingAlgorithms: custom_inline: type: CLASS_BASED props: strategy: STANDARD algorithmClassName: com.example.CustomShardingAlgorithm （3）重启shardingsphere-proxy服务，即可使用自定义算法类 ","date":"2025-03-28T17:31:02+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/java/shardingsphere/cover_hu2142890986032520167.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/java/shardingsphere/","title":"【Java】SpringBoot整合ShardingSphere"},{"content":" 前言：\n博客文章统计组件个人找到了两个，分别是不蒜子，以及vercount 不蒜子比较老，但很稳定，到现在仍然可以使用，没有停服 vercount则比较新，并做了一些代码优化 两种使用都基本一样，差别不大，看自己喜好，下面的教程是以vercount来举例，用不蒜子的话，就把对应的脚本和元素标签替换一下就好 1 基本引入 （1）修改layouts/partials/footer/custom.html（不存在则自行创建），引入脚本 1 2 \u0026lt;!-- vercount的脚本；若用不蒜子，则更换成不蒜子的脚本就好 --\u0026gt; \u0026lt;script defer src=\u0026#34;https://cn.vercount.one/js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）准备一张浏览量的icon(Ctrl+S保存)，放到assets/icons文件夹下 （3）修改layouts/article/components/details.html，在合适的位置下加入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 浏览量统计 --\u0026gt; \u0026lt;div id=\u0026#34;viewCount\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;eye\u0026#34; }} \u0026lt;time class=\u0026#34;article-time--reading\u0026#34;\u0026gt; \u0026lt;!-- vercount统计当前页面浏览数的标签；若用不蒜子，更换成不蒜子对应的标签就好 --\u0026gt; \u0026lt;span id=\u0026#34;vercount_value_page_pv\u0026#34;\u0026gt;loading... \u0026lt;/span\u0026gt;次 \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; （4）这样文章详情的开头就显示浏览数了 2 问题修复 问题描述： 博客首页的文章列表显示了浏览数，且只有第一篇文章才有浏览数，并且浏览数的数字不正确 产生原因： layouts/partials/article/components/details.html此html文件也被用在了博客首页的文章列表，所以也触发了vercount读取当前页面的浏览数 因为读取的数据是当前页面的浏览数，也就是首页的浏览数，并非文章的浏览数，所以数据只加载一次，且不准确 解决思路： 由于vercount并未提供只查询文章浏览数的接口，只有一个文章浏览数+1，并且返回浏览数的接口，所以无法实现首页对每篇文章的浏览数的单独查询 既然无法实现首页展示每篇文章的单独浏览数，那就直接隐藏就好了，等点入文章才看到具体的浏览数 具体操作： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;script\u0026gt; function showHideView() { // 判断是否存在vercount标签 let viewCounts = document.querySelectorAll(\u0026#34;#viewCount\u0026#34;); if (viewCounts) { // 判断是否为文章页 let article = document.querySelector(\u0026#34;.article-page\u0026#34;); if (!article) { viewCounts.forEach(ele =\u0026gt; { ele.style.display = \u0026#39;none\u0026#39;; }); } } } showHideView(); \u0026lt;/script\u0026gt; 如果嫌麻烦，浏览数统计可以和更新时间一样，放到文章末尾就好，就不会显示到首页上了 具体修改layouts/partials/article/footer.html就好，看个人喜好吧 ","date":"2025-02-28T11:29:14+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/view-count/cover_hu13397988041983243305.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/view-count/","title":"【Hugo】博客文章浏览数统计"},{"content":" 前言：\n这是从 【Hugo】Aplayer + PJAX 引入音乐播放放器并实现音乐不中断功能 中单独摘出的内容，内容一模一样 单独开一篇新文章，用来更新引入PJAX带来的问题，就不更新在音乐播放器那篇文章上了 此教程是基于Stack-3.26.0，不确保其他版本是否生效，若不生效请自行阅读源码修复 1 引入PJAX （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的 【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象 （4）根据官方文档，在layouts/partials/footer/custom.html加入以下代码来引入PJAX 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n2 问题修复 2.1 文章样式修复 问题描述： 随便点进其中一篇文章，可以发现文章内容的样式丢失 产生原因： \u0026lt;body\u0026gt;标签中的class名缺失article-page，导致文章样式丢失 解决思路： 通过官方提供了数据预处理方法，来预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 具体步骤： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) } // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 2.2 主题切换修复 问题描述： 当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 产生原因： 阅读Stack主题源码assets/ts/colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 解决思路： 在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。 阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 具体步骤： （1）修改layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 \u0026lt;script\u0026gt; document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 2.3 文章搜索修复 问题描述： 使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 产生原因： 查看assets/ts/search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 解决思路： 把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来 由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 具体步骤： （1）修改assets/ts/search.tsx代码，封装方法并export 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } （2）修改assets/ts/main.ts，引入搜索初始化方法并调用 1 2 3 4 5 6 7 8 9 ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （3）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 2.4 搜索内容跳转修复 问题描述： 虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了 产生原因： 阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。 解决思路： 阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 具体步骤： （1）修改assets/ts/search.tsx，在动态渲染数据方法末尾让pjax重新解析文档 1 2 3 4 5 6 7 8 9 private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 2.5 文章评论修复 问题描述： 如果博客有开启评论功能的话，会发现评论的脚本不生效了 产生原因： pjax引入自动执行的脚本，不支持自行执行 解决思路： 由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理： 用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 具体步骤： （1）修改layouts/partials/footer/custom.html，把实际的评论参数填写进行下面模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 实例演示(Giscus评论)： （1）修改layouts/partials/comments/include.html，添加一个元素标识，方便判断文章是否开启了评论 1 2 3 4 {{ if .Site.Params.comments.enabled }} ... \u0026lt;div class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; {{ end }} （2）找到Stack主题的giscus评论文件layouts/partials/comments/provider/giscus.html （3）按照上面给出的模板，结合giscus文件，在layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; {{- with .Site.Params.comments.giscus -}} \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; (function () { // 判断当前是否有文章评论标识 let comment = document.querySelector(\u0026#34;.comment\u0026#34;); if (!comment) { return } let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;src\u0026#39;, \u0026#39;https://giscus.app/client.js\u0026#39;); script.setAttribute(\u0026#39;data-repo\u0026#39;, \u0026#39;{{- .repo -}}\u0026#39;); // ...以此类推 script.async = true; // 寻找合适的元素，添加脚本进去(在页脚前将评论脚本插入) document.querySelector(\u0026#39;.site-footer\u0026#39;).before(script) })(document); \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; {{- end -}} 2.6 KaTeX修复 问题描述： 点进含有 数学公式(KaTeX) 的文章，里面的数学公式不能正常渲染出来 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n产生原因： 阅读源码layouts/partials/article/components/math.html，KaTeX渲染公式需要执行renderMathInElement，而PJAX的无刷新技术无法触发DOMContentLoaded的监听 解决思路： 将KaTeX渲染方法renderMathInElement封装为函数，交由PJAX加载结束后执行 具体操作： （1）修改layouts/partials/article/components/math.html，添加一个元素标签，便于判断文档是否使用了KaTeX 1 2 ... \u0026lt;div class=\u0026#34;math-katex\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; （2）layouts/partials/footer/custom.html，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;script\u0026gt; async function renderKaTeX() { // 判断当前页面是否有KateX let katex = document.querySelector(\u0026#34;.math-katex\u0026#34;); if (!katex) { return; } // 等待函数加载成功后，再执行渲染方法 while (typeof renderMathInElement !== \u0026#39;function\u0026#39;) { await delay(500); } // KaTeX渲染方法 renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); } /** * 同步延迟 */ function delay(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time) }) } document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { renderKaTeX(); }) \u0026lt;/script\u0026gt; 3 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度\n（2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2025-02-26T13:46:57+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/pjax/cover_hu15269159841050007592.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/pjax/","title":"【Hugo】PJAX实现无刷新加载页面"},{"content":" 1 写轮眼加载动画 这边先介绍如何引入本博客的加载动画，直接复制就能实现，适用于代码二次开发能力不强的用户 \u0026ldquo;授人以鱼不如授人以渔\u0026quot;，后面会教大家如何引入自己想要的加载动画 1.1 基本引入 将以下代码复制进layouts/partials/head/custom.html(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sharingon\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ring\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;to\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;circle\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .loading { position: fixed; display: flex; justify-content: center; align-items: center; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; zoom: 3.0; background-color: #f5f5fa; } .animated-stop { animation-play-state: paused !important; } .scaleAndFadeout { animation: scaleAndFadeOut 1.5s forwards; } /** 放大1.5倍，并渐变到透明 */ @keyframes scaleAndFadeOut { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(1.5); opacity: 0; } } /* From Uiverse.io by shadowfax29 */ .sharingon { position: relative; width: 6em; height: 6em; background-color: red; border: 6px solid black; animation: rot 1s ease-in-out infinite; } .ring { position: absolute; content: \u0026#34;\u0026#34;; left: 50%; top: 50%; width: 3.5em; height: 3.5em; border: 4px solid rgb(110, 13 ,13 ,0.5); transform: translate(-50%,-50%); } .sharingon, .ring, .to,.circle { border-radius: 50%; } .to,.circle { position: absolute; content: \u0026#34;\u0026#34;; width: 0.9em; height: 0.9em; background-color: black; } .to:nth-child(1) { top: -0.5em; left: 50%; transform: translate(-40%); } .to::before { content: \u0026#34;\u0026#34;; position: absolute; top: -0.5em; right: -0.2em; width: 1.1em; height: 0.9em; box-sizing: border-box; border-left: 16px solid black; border-radius: 100% 0 0; } .to:nth-child(2) { bottom: 0.5em; left: -0.35em; transform: rotate(-120deg); } .to:nth-child(3) { bottom: 0.5em; right: -0.35em; transform: rotate(120deg); } .circle { top: 50%; left: 50%; transform: translate(-50%,-50%); box-shadow: 0 0 20px 1px; width: 1em; height: 1em; } @keyframes rot { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt;\tfunction initLoading() { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 本地页面加载速度快，可自行使用setTimeout()来进行延迟，体验加载动画效果 // 执行加载完成动画 loadFinish(); // 延迟1.5s，待加载完成动画执行结束 setTimeout(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; }, 1500) }); } function loadFinish() { // 暂停动画 let sharingon= document.querySelector(\u0026#34;.sharingon\u0026#34;); sharingon.classList.add(\u0026#34;animated-stop\u0026#34;) // 放大并渐变到透明 let loading = document.querySelector(\u0026#34;.loading\u0026#34;); loading.classList.add(\u0026#34;scaleAndFadeout\u0026#34;) } initLoading(); \u0026lt;/script\u0026gt; 1.2 动画首次加载 每次切换页面都播放一次加载动画，这种看个人喜欢。 我个人是不太喜欢的，我只希望第一次打开这页面的时候加载一下就好 1.2.1 PJAX 如果你博客引入了PJAX功能，基本是不会出现这情况了。因为页头页脚一般不是PJAX会刷新的地方，所以页面切换时不会重复执行加载动画脚本 想了解PJAX可以去查看【Hugo】PJAX实现无刷新加载页面 1.2.2 SessionStorage PJAX技术对大部分轻度用户来说还是有点困难的，可以用SessionStorage存储一下页面是否已经播放过加载动画了，播放过了就不重新播放一遍，来平替PJAX技术\n(1) 将display改为none，默认不显示加载动画\n1 2 3 4 5 6 \u0026lt;style\u0026gt; .loading { ... display: none; } \u0026lt;/style\u0026gt; (2) 修改initLoading方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script\u0026gt; function initLoading() { const isFirstVisit = !sessionStorage.getItem(\u0026#39;visited\u0026#39;); if (isFirstVisit) { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); loading.style.display = \u0026#34;flex\u0026#34;; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 执行加载完成动画 loadFinish(); // 延迟1.5s，待加载完成动画执行结束 setTimeout(() =\u0026gt; { loading.style.display = \u0026#34;none\u0026#34;; }, 1500) sessionStorage.setItem(\u0026#39;visited\u0026#39;, \u0026#39;true\u0026#39;); }); } } \u0026lt;/script\u0026gt; (3) 这样就只有首次进入此网站时才播放加载动画，页面关闭后重新进入才再次播放加载动画 2 自定义加载动画 2.1 基本引入 (1) 前往UIverse，寻找自己喜欢的加载动画 (2) 将加载动画的html，css分别复制到下面的模板，然后将模板内容复制到layouts/partials/head/custom.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;div class=\u0026#34;loading\u0026#34;\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .loading { position: fixed; display: flex; justify-content: center; align-items: center; top: 0; left: 0; width: 100%; height: 100%; z-index: 99; background-color: #f5f5fa; } /* css内容 */ \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt;\tfunction initLoading() { let loading = document.querySelector(\u0026#34;.loading\u0026#34;); document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function() { // 本地页面加载速度快，可自行使用setTimeout()来进行延迟，体验加载动画效果 loading.style.display = \u0026#34;none\u0026#34;; }); } initLoading(); \u0026lt;/script\u0026gt; 这样就能实现最基本的加载动画效果 2.2 样式修改 因为每个人的加载动画都不一致，这边只分享一下可能会用到的css样式，实际情况还需自己自行适配 也可以参考上面的写轮眼动画的写法，来模仿写法 CSS样式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 可能会用到的CSS */ { /* 整体修改元素大小(大于1放大, 小于1缩小) */ zoom: 1.0; /* 开始动画播放 */ animation-play-state: running; /* 暂停动画播放 */ animation-play-state: paused; /* 元素居中(flex布局) */ display: flex; justify-content: center; align-items: center; /* 元素隐藏 */ display: none; /* 定义动画 */ @keyframes 动画名 { 0% {} 进度% {} 100% {} } /* 执行动画 */ animation: 动画名 时间; } CSS动画参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * CSS动画常用参数 */ { /* 不透明度 */ opacity: 1; /* 放大缩小 */ transform: scale(1); /* 旋转 */ transform: rotate(360deg); /* 平移(水平, 垂直) */ transform: translate(-100%, 0); } ","date":"2025-02-19T11:21:50+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/page-loading/cover_hu8681908609188190185.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/page-loading/","title":"【Hugo】博客引入页面加载动画"},{"content":" TODO: bilibili视频，不摸的话\n前言：\n用 live2d-widget 自带模型用腻了之后，想找一个自己喜欢的模型，就接触了moc3类型的模型。moc3类型是cubism新版模型的类型，而旧版模型的类型是moc模型 而live2d-widget并不支持moc3模型，只支持moc模型，所以寻找新的组件来适配moc3模型。找到了以下两个组件 oh-my-live2d 和 Live2dOnWeb ，但这两组件或多或少有自己的毛病，不及 live2d-widget 使用方便 于是个人基于 live2d-widget 框架，对moc3类型的模型进行适配，诞生了此项目 live2d-widget-v3 1 基本引入 （1）找到博客的页头(head)或页脚(footer)，将以下代码引入进去 tips: stack主题的页脚在layouts/partials/footer/custom.html，可以修改此html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \u0026lt;script\u0026gt; const cdnPath = \u0026#34;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#34;; const config = { // 资源路径 path: { homePath: \u0026#34;/\u0026#34;, modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // 工具栏 tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;photo\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // 模型拖拽 drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // 模型切换(order: 顺序切换，random: 随机切换) switchType: \u0026#34;order\u0026#34; } // 加载资源并初始化 if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // 异步加载资源 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; （2）这样就引入好了，模型是官方sdk自带的，模型的位置在仓库的/Resources目录下 2 自定义适配 2.1 调整css和提示语 （1）css样式调整和提示语的调整，跟live2d-widget无异，从仓库中下载waifu.css和waifu-tips.json文件，放入博客中，通过本地引入方式，修改代码中config.path.cssPath和config.path.tipsJsonPath这两个参数 （2）具体操作和调整方式，请参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.2 自定义模型 （1）自定义模型方式也是和live2d-widget基本无异(因为就是基于live2d-wdiget进行二开的)，准备好 model 和 model_list.json 文件，可直接下载本仓库代码中的/Resources目录 （2）将自己的自定义模型中放入model目录，修改 model_list.json 文件，最后修改config.path.modelPath通过cdn的形式引入文件 （3）具体操作参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.3 自定义模型-拓展 除了live2d-widget原生的功能外，个人还进行了一些功能拓展 接下来会以本站的模型，也是这位【b站up主】所提供的免费模型进行演示 如果你也使用此模型，请勿吝啬你的点赞、投币，收藏，来支持一下此up主 2.3.1 调整模型大小和位置 在模型的目录下，创建一个config.json文件，将以下内容复制进去，修改参数就可以对大小和位置进行调整 【在线调整地址】 scale: 模型大小 translate.x: 模型x轴偏移量 translate.y: 模型y轴偏移量 1 2 3 4 5 6 7 { \u0026#34;scale\u0026#34;: 1.0, \u0026#34;translate\u0026#34;: { \u0026#34;x\u0026#34;: 0.0, \u0026#34;y\u0026#34;: 0.0 } } 2.3.2 适配模型表情 模型文件中如果存在xxx.exp3.json文件，此文件为模型的表情文件 可修改xxx.model3.json，按照以下格式，进行配置 1 2 3 4 5 6 7 8 9 10 11 12 { ... \u0026#34;FileReferences\u0026#34;: { ..., \u0026#34;Expressions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;表情名\u0026#34;, \u0026#34;File\u0026#34;: \u0026#34;表情文件路径\u0026#34; } ] } } 这样点击侧边工具栏的标签按钮，就会随机切换表情了 2.3.3 适配模型动作 若模型存在xxx.motion3.json文件，此文件为模型的动作文件 可以修改xxx.model3.json文件，按照以下格式，进行配置 动作的触发分为两种，配置时选其中一种配置即可 Idel：闲置动作，会一直从闲置动作数组中，随机选一个进行播放 TapBody：点击动作，当点击画布时，才会从点击动作数组中，随机选一个进行播放 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { ... \u0026#34;FileReferences\u0026#34;: { ... \u0026#34;Motions\u0026#34;: { \u0026#34;Idle\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ], \u0026#34;TapBody\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ] } } } 因为我配置的是TapBody，所以点击模型时，会触发模型的招手动作 3 优化 3.1 png转webp 为了优化模型的加载速度，可以将模型中的皮肤png文件，转为webp文件【在线转换地址】 清晰度几乎没有变化，但皮肤文件的小了有10倍多，可以减少网络请求量，从而加快加载速度 转完webp文件后，修改xxx.model3.json文件，将皮肤文件从png改成webp 这样网络请求时要加载的数据量就会少很多 ","date":"2024-11-14T15:21:35+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/cover_hu11373105535066101579.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/","title":"【Hugo】博客引入moc3类型的live2d模型"},{"content":" TODO：bilibili视频，不摸的话\n1 修改背景图 (1) 准备一张背景图，尽可能大一点，并放到assets/background文件夹下(不存在则自己创建) (2) 在页脚文件layouts/partials/footer/custom.html中(不存在则自己创建)，引入以下代码，修改对应的背景图片名 不同的主题对应的页脚文件不同，按自己实际主题的页脚文件引入代码\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 2 引入动态背景 2.1 樱花飞舞 (1) 下载【sakura.js】(Ctrl + S 保存)，并放到assets/background文件夹下\n(2) 在layouts/partials/footer/custom.html中，引入以下代码\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 2.2 点线漂浮(particles.js) 【particles.js文档】\n(1) 前往【配置页面】配置参数，参数按自己喜好即可，唯一注意要修改的参数是 detect_on，要改成 window\n(2) 下载配置文件，以及 particles.js 所需要的js文件 【particlesjs-config.json】(Ctrl + S 保存)，本博客的动态背景json配置，有需求的可直接下载 (3) 把下载好的文件，解压并将以下两个文件放到assets/background文件夹下 particlesjs-config.json particles.min.js (4) 在layouts/partials/footer/custom.html中，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src={{ (resources.Get \u0026#34;background/particles.min.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; particlesJS.load(\u0026#39;particles-js\u0026#39;, {{ (resources.Get \u0026#34;background/particlesjs-config.json\u0026#34;).Permalink }}, function() { console.log(\u0026#39;particles.js loaded - callback\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #particles-js { position: fixed; top: 0; left: 0; width: 100%; z-index: -1; } \u0026lt;/style\u0026gt; ","date":"2024-10-12T15:59:49+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/cover_hu14760223960418122026.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/","title":"【Hugo】修改博客背景并引入动态背景"},{"content":" TODO：bilibili视频，可能做，可能不做，内容比较杂，不太好做视频\n1 修改字体 (1) 前往【100font】，下载自己想要的字体，这边演示缝合像素字体，字体文件为 fusion-pixel-10px-monospaced-zh_hans.ttf (2) 把字体文件放入assets/font下(文件夹自己创建) (3) 将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建) 字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; (4) 这样博客字体就修改好了 2 修改鼠标样式 (1) 准备好鼠标样式图片(默认，指针，文本\u0026hellip;)，图片大小建议控制在 32px 左右，将图片放入static/mouse文件夹下(文件夹自己创建) 演示鼠标来源：【B站up主】 (2) 修改assets/scss/custom.scss(文件不存在则自己创建)，将以下代码复制进去，根据主题按实际情况填写对应的css选择器 1 2 3 4 5 6 7 8 9 10 11 // 【鼠标样式常规写法】 body, html { cursor: url(../mouse/默认光标图片名), auto !important; } css选择器 { cursor: url(../mouse/其他光标图片名), auto; } (3) 以下是我调试好的 stack 主题的鼠标样式，同样是stack主题的可以直接复制，修改对应的图片名即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 【Stack主题鼠标样式写法】 // default光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 3 显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置 1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 修改github action文件.github/workflows/xxx.yaml，在运行 hugo -D 命令的step前加入以下配置 1 2 3 4 5 6 7 8 9 jobs: deploy: steps: - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false (3) 这样就提交代码时，就会去读取git时间，来更新文章的更新时间 stack主题的文章更新时间在文章底部 (4) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/details.html，在指定位置引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 tips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 4 友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 5 文章目录折叠\u0026amp;展开 (1) 将以下代码复制到layouts/partials/footer/custom.html文件中(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { //清除class值 let openUl = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (openUl.length \u0026gt; 0) { openUl.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; (2) 这样文章就会默认隐藏子目录，等滚动到对应的目录后，才会将子目录进行展示 6 添加\u0026rsquo;返回顶部\u0026rsquo;按钮 (1) 准备一张返回顶部图片(Ctrl+S保存)，放到assets/icons文件夹下(不存在则自行创建) (2) 将以下代码复制到layouts/partials/footer/custom.html文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/backTop.svg\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; (3) 这样当我们页面滚动到一定距离后，右下角会出现返回顶部的按钮，点击后可以平滑地返回顶部 7 macOS风格的代码块 (1) 准备一张macOS代码块的红绿灯图片(Ctrl+S保存), 放到static/icons文件夹下 (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; } .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(../icons/macOS-code-header.svg) no-repeat 0; background-size: contain; height: 18px; margin-top: -10px; margin-bottom: 10px; } 8 自定义MD引用块颜色模板 参考文章：让Hugo支持GitHub风格的块引用Alerts\n(1) 创建文件layouts/_default/_markup/render-blockquote-alert.html，并将以下代码复制进去\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 配色参考来源：martignoni/hugo-notice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-warn { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-error { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-warn { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-error { --card-separator-color: #880000; --blockquote-background-color: #450000; } } (3) 使用方法 可选项：NOTE | TIP | WARN | ERROR 可仿照上面css写法，自行添加新的css样式，来实现更多的可选项 1 2 \u0026gt; [!NOTE] \u0026gt; 这是markdown的引用块语法 (4) 效果演示 这是NOTE风格\n这是TIP风格\n这是WARN风格\n这是ERROR风格\n9 代码块过长折叠\u0026amp;展开 代码块折叠的样式风格完全仿照CSDN来实现的\n(1) 准备一张向下展开图片(Ctrl+S保存)，放到assets/icons目录下 (2) 将以下代码复制进layouts/partials/footer/custom.html(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; // 触发resize事件，重新计算目录位置 window.dispatchEvent(new Event(\u0026#39;resize\u0026#39;)) }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; ","date":"2024-10-08T11:10:25+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/cover_hu782432619297144394.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/","title":"【Hugo】Stack主题自定义修改"},{"content":" 1. 基础引入 【Live2d-widget文档】 （1）查看官方文档，引入对应的js脚本到layouts\\partials\\footer\\custom.html中(详情看引入音乐播放器的文章) 1 2 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）成功在左下角引入了live2d看板娘 2. 自定义适配 看板娘是已经引入好了，但是显示在左下角，跟我当前的主题非常的不搭，需要对看板娘进行自定义，来适配主题\n2.1 抽离autoload.js (1) 前往【Live2d-widget文档】，把 waifu-tips.json 和 waifu.css下载，并放到assets/waifu文件夹中(自己新建) (2) 把之前引入的 autoload.js 删掉，把下面代码引入到 custom.html 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; // 获取博客本地资源地址 const cssPath = {{ (resources.Get \u0026#34;waifu/waifu.css\u0026#34;).Permalink }} const tipsJsonPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.json\u0026#34;).Permalink }} // live2d_path 参数建议使用绝对路径 const live2d_path = \u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\u0026#34;; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(cssPath, \u0026#34;css\u0026#34;), loadExternalResource(live2d_path + \u0026#34;live2d.min.js\u0026#34;, \u0026#34;js\u0026#34;), loadExternalResource(live2d_path + \u0026#34;waifu-tips.js\u0026#34;, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { // 配置选项的具体用法见 README.md initWidget({ waifuPath: tipsJsonPath, cdnPath: \u0026#34;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\u0026#34;, tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;photo\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;] }); }); } \u0026lt;/script\u0026gt; 2.2 调整css样式 (1) 修改assets/waifu/waifu.css，将看板娘移动到右侧，更加适配Stack主题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 【waifu.css】 */ #waifu-toggle { ... /* left: 0; */ right: 0; /* margin-left: -100px; */ margin-right: -90px; /* writing-mode: vertical-rl; */ writing-mode: vertical-lr; } #waifu-toggle.waifu-toggle-active { /* margin-left: -50px; */ margin-right: -40px; } #waifu-toggle.waifu-toggle-active:hover { /* margin-left: -30px; */ margin-right: -20px; } #waifu { ... /* left: 0; */ right: 10px; } #waifu-tool { ... /* right: -10px; */ margin-left: 260px; } (2) 这样看板娘就成功移动到右下角了 2.3 调整看板娘提示语 (1) 修改assets/waifu/waifu-tips.json，修改里面的css选择器，来适配页面内容元素，这边以复制按钮为例\n(2) 查看复制按钮的元素，属性为class=\u0026quot;copyCodeButton\u0026quot;\n(3) 修改assets/waifu/waifu-tips.json，新增or修改对应的文本，修改对应的css选择器 (4) 这样当我们鼠标移动到对应的元素之后，看板娘就会有对应的提示语 2.4 自定义模型 2.4.1 引入cdn (1) 前往【live2d_api】，下载代码，这仓库中的文件就是 live2d-widget 的所使用的模型\n(2) 修改model_list.json文件，来添加or删除live2d模型（若有属于自己的live2d模型，请将模型放到model文件夹下）\n(3) 引入live2d文件可以本地引入(具体看音乐播放器文章)，这次演示用cdn的形式引入，cdn使用的是【jsDelivr】\n(4) cdn引入不需要php文件，将多余的php文件删掉，只保留 model 和 model_list.json\n(5) github新建一个公有(public)仓库，将代码上传到仓库上，打标签(Tags)并发布(Releases)一个版本 (6) 修改layouts/partials/footer/custom.html文件中的cdnPath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { initWidget({ ... // 有文件夹就在后面拼文件夹路径 cdnPath: \u0026#34;https://cdn.jsdelivr.net/gh/{用户名}/{仓库名}@{标签名}/\u0026#34;, ... }); }); } \u0026lt;/script\u0026gt; (7) 这样就成功通过cdn的形式引入自己的live2d模型文件 2.4.2 bug修复 如果你 model_list.json 中的 live2d模型分组 只有一组的时候，会存在bug，导致加载不出模型，需要进行修复\n(1) 前往【Live2d-widget】，下载 waifu-tips.js，并放到assets/waifu文件夹下，修改 custom.html 来引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const tipsJsPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (2) 修改 waifu-tips.js 文件，全局搜索e=1,o=53，将内容改为e=0,o=0，这两个值是默认模型和默认皮肤，所以一旦模型分组小于2的时候，就会找不到模型(代码顺序从0开始数) (3) 打开浏览器，按F12打开控制台，清理 localStorage(本地存储) 中的数据 (4) 这样加载模型默认加载第0个模型，bug就修复了 3 优化 3.1 多皮肤切换修复 （1）某些模型是具有多皮肤的(例如22, 33之类的)，但切换皮肤按钮不生效，是因为cdn形式引入是不适配皮肤切换的\n（2）这边对cdn引入方式的皮肤切换功能做了适配，下载我修改过的 live2d.min.js ，放到assets/waifu下，通过本地的形式引入\nlive2d.min.js（Ctrl+S保存） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const live2dJsPath = {{ (resources.Get \u0026#34;waifu/live2d.min.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;), ... ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (3) 这样就能切换这些看板娘的皮肤了 3.2 拖拽看板娘 (1) 有时候看板娘在右下角可能有点碍事，阻碍到我们点击一些页面内容，给看板娘添加拖拽功能，将她拖走\n(2) 将下面的代码复制进layouts\\partials\\footer\\custom.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { ... // 初始化看板娘鼠标监听事件 initWaifuMouseEvent(); }); } function initWaifuMouseEvent() { const waifu = document.getElementById(\u0026#34;waifu\u0026#34;); let isDown = false; let waifuLeft; let mouseLeft; let waifuTop; let mouseTop; // 鼠标点击监听 waifu.onmousedown = function (e) { isDown = true; // 记录x轴 waifuLeft = waifu.offsetLeft; mouseLeft = e.clientX; // 记录y轴 waifuTop = waifu.offsetTop; mouseTop = e.clientY; } // 鼠标移动监听 window.onmousemove = function (e) { if (!isDown) { return; } // x轴移动 let currentLeft = waifuLeft + (e.clientX - mouseLeft); if (currentLeft \u0026lt; 0) { currentLeft = 0; } else if (currentLeft \u0026gt; window.innerWidth - 300) { currentLeft = window.innerWidth - 300; } waifu.style.left = currentLeft + \u0026#34;px\u0026#34;; // y轴移动 let currentTop = waifuTop + (e.clientY - mouseTop); if (currentTop \u0026lt; 30) { currentTop = 30 } else if (currentTop \u0026gt; window.innerHeight - 290) { currentTop = window.innerHeight - 290 } waifu.style.top = currentTop + \u0026#34;px\u0026#34;; } // 鼠标点击松开监听 window.onmouseup = function (e) { isDown = false; } } \u0026lt;/script\u0026gt; (3) 这样就可以随意拖拽看板娘了（如果是没有腿的模型，建议把y轴移动的代码注释掉） ","date":"2024-09-19T17:17:34+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/cover_hu3013000311457165536.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/","title":"【Hugo】Live2d-widget 给博客引入萌萌的看板娘"},{"content":" 1 引入音乐播放器 【Aplayer官方文档】\n（1）在博客主目录中创建文件layouts\\partials\\footer\\custom.html，此文件为Stack主题作者留给我们加入自定义组件用的文件(可以查看主题源码同路径文件找到) （2）查看官方文档，引入对应的脚本，css到custom.html中，页面最下面就会出现音乐播放器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; （3）修改 ap对象 配置，改成吸底模式 1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); （4）填写 audio 数组，引入歌曲，封面和歌词 lrcType 的值具体看【文档】 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const staticDir = {{ .Site.Home.Permalink }} const ap = new APlayer({ ..., lrcType: 3, audio: [ { name: \u0026#39;name\u0026#39;, // 歌名 artist: \u0026#39;artist\u0026#39;, // 歌手 url: \u0026#39;url.mp3\u0026#39;, // 歌曲路径 cover: \u0026#39;cover.jpg\u0026#39;, // 封面路径 lrc: \u0026#39;lrc.lrc\u0026#39;, // 歌词路径 }, { // 本地路径引入写法（有子目录就在staticDir后面继续拼接） name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: staticDir + \u0026#39;url.mp3\u0026#39;, cover: staticDir + \u0026#39;cover.jpg\u0026#39;, lrc: staticDir + \u0026#39;lrc.lrc\u0026#39;, } ] }); 到这一步音乐播放器已经引入完了\n2 音乐播放器样式切换 （1）通过阅读Stack主题的源码可以看到，主题样式的切换是通过[data-scheme=\u0026quot;light/darck\u0026quot;] {...}\n（2）所以我们可以准备两种Aplayer的css，用[data-scheme=\u0026quot;light\u0026quot;]{ 亮的css样式 }包裹亮的，用[data-scheme=\u0026quot;dark\u0026quot;]{ 暗的css样式 }包裹暗的，这里直接给各位准备好了\naplayer-light.scss（Ctrl+S保存） aplayer-dark.scss（Ctrl+S保存） （3）在博客主目录中创建文件assets\\scss\\custom.scss，此文件为Stack主题作者留给我们加入自定义样式用的文件(可以查看主题源码同路径文件找到) （4）将上述两个scss文件放到跟 custom.scss同目录下，并通过@import来进行引入文件\n1 2 3 4 5 /** * 【custom.scss】 */ @import \u0026#34;aplayer-light.scss\u0026#34;; @import \u0026#34;aplayer-dark.scss\u0026#34;; （5）因为音乐播放器的css改为我们本地文件引入了，所以 custom.html 中的link标签可以将它注释掉或者删掉了 1 2 3 \u0026lt;!-- custom.html --\u0026gt; ... \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; --\u0026gt; 到这一步样式随主题切换已经完成了\n3 音乐播放进度保留 （1）实现思路：页面切换前，把歌曲的 歌曲序号，播放时长，播放状态 记录下来；在页面切换加载完之后，我们调用Aplayer的接口切换歌曲，调整时长，并选择播放or暂停\n（2）通过console.log(ap)打印ap对象，或者官方文档，可以找到我们需要的参数\nlist.index：歌曲序号 audio.currentTime：播放时长 paused ：播放状态（是否暂停） （3）通过【官方文档】可以查找到我们需要调用的接口\nap.list.switch(index: number)：切换歌曲 ap.seek(time: number)：调整时长 ap.play()：播放歌曲 （4）需要的东西已经找齐，只需在 custom.html 加入以下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... /** * 页面销毁前监听 */ window.onbeforeunload = () =\u0026gt; { // 将播放信息用对象封装，并存入到localStorage中 const playInfo = { index: ap.list.index, currentTime: ap.audio.currentTime, paused: ap.paused }; localStorage.setItem(\u0026#34;playInfo\u0026#34;, JSON.stringify(playInfo)); }; /** * 页面加载后监听 */ window.onload = () =\u0026gt; { // 从localStorage取出播放信息 const playInfo = JSON.parse(localStorage.getItem(\u0026#34;playInfo\u0026#34;)); if (!playInfo) { return; } // 切换歌曲 ap.list.switch(playInfo.index); // 等待500ms再执行下一步(切换歌曲需要点时间，不能立马调歌曲进度条) setTimeout(() =\u0026gt; { // 调整时长 ap.seek(playInfo.currentTime); // 是否播放 if (!playInfo.paused) { ap.play() } }, 500); }; \u0026lt;/script\u0026gt; 到这一步音乐播放进行已经完成了\n4 引入PJAX PJAX已单独创建到一篇新的文章上 【Hugo】PJAX实现无刷新加载页面 后续相关问题将在新文章中更新，不会在此文章进行更新 ⚠️建议直接看新文章来引入PJAX 4.1 基本引入 （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的\n【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象 （4）根据官方文档，在 custom.html 加入以下代码来引入PJAX\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n4.2 文章样式修复 （1）随便点进其中一篇文章，可以发现文章内容的样式丢失，缺少文章该有的边框 （2）通过手动刷新，对比页面元素发现，决定文章样式的是\u0026lt;body\u0026gt; 标签中的class名: article-page，存在此class名就会识别到文章该有的css （3）因为\u0026lt;body\u0026gt;内包含整个页面的所有内容，包括我们的音乐播放器，所以不能让PJAX监听\u0026lt;body\u0026gt;标签\n阅读官方文档发现，官方提供了数据预处理方法，让我们处理数据 我们通过预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { if (responseText) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 这样我们切页面后，都会自动把body中的className更新，就不会丢失样式了\n4.3 主题切换修复 （1）当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 （2）阅读Stack主题源码\\assets\\ts\\colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 （3）解决思路：在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。\n阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 这样元素的点击事件重新绑定，主题颜色就能正常切换了\n4.4 文章搜索修复 （1）使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 （2）查看layouts\\ts\\search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 （3）解决思路类似上面的，把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来，由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 - （以下操作请复制同路径同名文件到自己主目录下修改，不要在主题源码中修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 【search.tsx】 * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【main.ts】 */ ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （4）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 这样search.tsx能正常初始化，文章搜索功能恢复\n4.5 搜索内容跳转修复 （1）虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了\n（2）阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【search.tsx】 */ private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 这样动态渲染出的页面数据就能被PJAX识别到，就不会刷新页面跳转了\n4.6 文章评论修复 （1）如果博客有开启评论功能的话，会发现评论的脚本不生效了\n（2）由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理：\n用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- custom.thml --\u0026gt; ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 这样PJAX会自动加载我们的评论脚本\n5 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度\n（2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2024-08-14T14:50:54+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/cover_hu6146897835255991630.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/","title":"【Hugo】APlayer + PJAX 引入音乐播放放器并实现音乐不中断功能"},{"content":" 1 环境准备 1.1 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可 1.2 Hugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip 2 搭建博客 2.1 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行 （2）敲打命令hugo new site xxxx创建hugo文件 （3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中 （4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 2.2 配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载 （2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content （4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 （5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章 3 Github部署 3.1 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 3.2 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件\n（2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main ","date":"2024-07-22T15:44:59+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/%E5%B0%81%E9%9D%A2_hu14931377072575281322.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/","title":"【Hugo】Hugo + Github 免费部署自己的博客"}]