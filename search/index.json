[{"content":" TODO: bilibili视频，不摸的话\n前言：\n用 live2d-widget 自带模型用腻了之后，想找一个自己喜欢的模型，就接触了moc3类型的模型。moc3类型是cubism新版模型的类型，而旧版模型的类型是moc模型 而live2d-widget并不支持moc3模型，只支持moc模型，所以寻找新的组件来适配moc3模型。找到了以下两个组件 oh-my-live2d 和 Live2dOnWeb ，但这两组件或多或少有自己的毛病，不及 live2d-widget 使用方便 于是个人基于 live2d-widget 框架，对moc3类型的模型进行适配，诞生了此项目 live2d-widget-v3 1 基本引入 （1）找到博客的页头(head)或页脚(footer)，将以下代码引入进去 tips: stack主题的页脚在layouts/partials/footer/custom.html，可以修改此html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;script\u0026gt; const cdnPath = \u0026#39;https://cdn.jsdelivr.net/gh/letere-gzj/live2d-widget-v3@main\u0026#39;; const config = { // 资源路径 path: { modelPath: cdnPath + \u0026#34;/Resources/\u0026#34;, cssPath: cdnPath + \u0026#34;/waifu.css\u0026#34;, tipsJsonPath: cdnPath + \u0026#34;/waifu-tips.json\u0026#34;, tipsJsPath: cdnPath + \u0026#34;/waifu-tips.js\u0026#34;, live2dCorePath: cdnPath + \u0026#34;/Core/live2dcubismcore.js\u0026#34;, live2dSdkPath: cdnPath + \u0026#34;/live2d-sdk.js\u0026#34; }, // 工具栏 tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;express\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;], // 模型拖拽 drag: { enable: true, direction: [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] }, // 模型切换(order: 顺序切换，random: 随机切换) switchType: \u0026#34;order\u0026#34; } // 加载资源并初始化 if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(config.path.cssPath, \u0026#34;css\u0026#34;), loadExternalResource(config.path.live2dCorePath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.live2dSdkPath, \u0026#34;js\u0026#34;), loadExternalResource(config.path.tipsJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { initWidget({ waifuPath: config.path.tipsJsonPath, cdnPath: config.path.modelPath, tools: config.tools, dragEnable: config.drag.enable, dragDirection: config.drag.direction, switchType: config.switchType }); }); } // 异步加载资源 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } \u0026lt;/script\u0026gt; （2）这样就引入好了，模型是官方sdk自带的，模型的位置在仓库的/Resources目录下 2 自定义适配 2.1 调整css和提示语 （1）css样式调整和提示语的调整，跟live2d-widget无异，从仓库中下载waifu.css和waifu-tips.json文件，放入博客中，通过本地引入方式，修改代码中config.path.cssPath和config.path.tipsJsonPath这两个参数 （2）具体操作和调整方式，请参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.2 自定义模型 （1）自定义模型方式也是和live2d-widget基本无异(因为就是基于live2d-wdiget进行二开的)，准备好 model 和 model_list.json 文件，可直接下载本仓库代码中的/Resources目录 （2）将自己的自定义模型中放入model目录，修改 model_list.json 文件，最后修改config.path.modelPath通过cdn的形式引入文件 （3）具体操作参考【Hugo】Live2d-widget 给博客引入萌萌的看板娘 2.3 自定义模型-拓展 除了live2d-widget原生的功能外，个人还进行了一些功能拓展 接下来会以本站的模型，也是这位【b站up主】所提供的免费模型进行演示 如果你也使用此模型，请勿吝啬你的点赞、投币，收藏，来支持一下此up主 2.3.1 调整模型大小和位置 在模型的目录下，创建一个config.json文件，将以下内容复制进去，修改参数就可以对大小和位置进行调整 【在线调整地址】 scale: 模型大小 translate.x: 模型x轴偏移量 translate.y: 模型y轴偏移量 1 2 3 4 5 6 7 { \u0026#34;scale\u0026#34;: 1.0, \u0026#34;translate\u0026#34;: { \u0026#34;x\u0026#34;: 0.0, \u0026#34;y\u0026#34;: 0.0 } } 2.3.2 适配模型表情 模型文件中如果存在xxx.exp3.json文件，此文件为模型的表情文件 可修改xxx.model3.json，按照以下格式，进行配置 1 2 3 4 5 6 7 8 9 10 11 12 { ... \u0026#34;FileReferences\u0026#34;: { ..., \u0026#34;Expressions\u0026#34;: [ { \u0026#34;Name\u0026#34;: \u0026#34;表情名\u0026#34;, \u0026#34;File\u0026#34;: \u0026#34;表情文件路径\u0026#34; } ] } } 这样点击侧边工具栏的标签按钮，就会随机切换表情了 2.3.3 适配模型动作 若模型存在xxx.motion3.json文件，此文件为模型的动作文件 可以修改xxx.model3.json文件，按照以下格式，进行配置 动作的触发分为两种，配置时选其中一种配置即可 Idel：闲置动作，会一直从闲置动作数组中，随机选一个进行播放 TapBody：点击动作，当点击画布时，才会从点击动作数组中，随机选一个进行播放 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { ... \u0026#34;FileReferences\u0026#34;: { ... \u0026#34;Motions\u0026#34;: { \u0026#34;Idle\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ], \u0026#34;TapBody\u0026#34;: [ { \u0026#34;File\u0026#34;: \u0026#34;动作文件路径\u0026#34; } ] } } } 因为我配置的是TapBody，所以点击模型时，会触发模型的招手动作 3 优化 3.1 png转webp 为了优化模型的加载速度，可以将模型中的皮肤png文件，转为webp文件 清晰度几乎没有变化，但皮肤文件的小了有10倍多，可以减少网络请求量，从而加快加载速度 转完webp文件后，修改xxx.model3.json文件，将皮肤文件从png改成webp 这样网络请求时要加载的数据量就会少很多 ","date":"2024-11-14T15:21:35+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/cover_hu11373105535066101579.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/live2d-moc3/","title":"【Hugo】博客引入moc3类型的live2d模型"},{"content":" TODO：bilibili视频，不摸的话\n1 修改背景图 (1) 准备一张背景图，尽可能大一点，并放到assets/background文件夹下(不存在则自己创建) (2) 在页脚文件layouts/partials/footer/custom.html中(不存在则自己创建)，引入以下代码，修改对应的背景图片名 不同的主题对应的页脚文件不同，按自己实际主题的页脚文件引入代码\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 2 引入动态背景 2.1 樱花飞舞 (1) 下载【sakura.js】(Ctrl + S 保存)，并放到assets/background文件夹下\n(2) 在layouts/partials/footer/custom.html中，引入以下代码\n1 \u0026lt;script src={{ (resources.Get \u0026#34;background/sakura.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; 2.2 点线漂浮(particles.js) 【particles.js文档】\n(1) 前往【配置页面】配置参数，参数按自己喜好即可，唯一注意要修改的参数是 detect_on，要改成 window\n(2) 下载配置文件，以及 particles.js 所需要的js文件 【particlesjs-config.json】(Ctrl + S 保存)，本博客的动态背景json配置，有需求的可直接下载 (3) 把下载好的文件，解压并将以下两个文件放到assets/background文件夹下 particlesjs-config.json particles.min.js (4) 在layouts/partials/footer/custom.html中，引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;div id=\u0026#34;particles-js\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src={{ (resources.Get \u0026#34;background/particles.min.js\u0026#34;).Permalink }}\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; particlesJS.load(\u0026#39;particles-js\u0026#39;, {{ (resources.Get \u0026#34;background/particlesjs-config.json\u0026#34;).Permalink }}, function() { console.log(\u0026#39;particles.js loaded - callback\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; #particles-js { position: fixed; top: 0; left: 0; width: 100%; z-index: -1; } \u0026lt;/style\u0026gt; ","date":"2024-10-12T15:59:49+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/cover_hu14760223960418122026.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-background/","title":"【Hugo】修改博客背景并引入动态背景"},{"content":" TODO：bilibili视频，可能做，可能不做，内容比较杂，不太好做视频\n1 修改字体 (1) 前往【100font】，下载自己想要的字体，这边演示缝合像素字体，字体文件为 fusion-pixel-10px-monospaced-zh_hans.ttf (2) 把字体文件放入assets/font下(文件夹自己创建) (3) 将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建) 字体名：给字体命名一个别名，随便填写就好，保持统一就行 字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; (4) 这样博客字体就修改好了 2 修改鼠标样式 (1) 准备好鼠标样式图片(默认，指针，文本\u0026hellip;)，图片大小建议控制在 32px 左右，将图片放入static/mouse文件夹下(文件夹自己创建) 演示鼠标来源：【B站up主】 (2) 修改assets/scss/custom.scss(文件不存在则自己创建)，将以下代码复制进去，根据主题按实际情况填写对应的css选择器 1 2 3 4 5 6 7 8 9 10 11 // 【鼠标样式常规写法】 body, html { cursor: url(../mouse/默认光标图片名), auto !important; } css选择器 { cursor: url(../mouse/其他光标图片名), auto; } (3) 以下是我调试好的 stack 主题的鼠标样式，同样是stack主题的可以直接复制，修改对应的图片名即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // 【Stack主题鼠标样式写法】 // default光标图片 body, html, .article-content img { cursor: url(../mouse/默认光标图片名), auto !important; } // pointer光标图片 a:hover, button:hover, .copyCodeButton:hover, #dark-mode-toggle { cursor: url(../mouse/指针光标图片名), auto; } // text光标图片 input:hover, .site-description, .article-subtitle, .article-content span, .article-content li, .article-content p { cursor: url(../mouse/文本光标图片名), auto; } 3 显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置 1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 修改github action文件.github/workflows/xxx.yaml，在运行 hugo -D 命令的step前加入以下配置 1 2 3 4 5 6 7 8 9 jobs: deploy: steps: - name: Git Configuration run: | git config --global core.quotePath false git config --global core.autocrlf false git config --global core.safecrlf true git config --global core.ignorecase false (3) 这样就提交代码时，就会去读取git时间，来更新文章的更新时间 stack主题的文章更新时间在文章底部 (4) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/details.html，在指定位置引入以下代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 tips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 4 友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 5 文章目录折叠\u0026amp;展开 (1) 将以下代码复制到layouts/partials/footer/custom.html文件中(文件不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;style\u0026gt; #TableOfContents \u0026gt; ul, ol { ul, ol { display: none; } .open { display: block; } } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initTocHide() { // 判断是否存在文章目录 let toc = document.querySelector(\u0026#34;.widget--toc\u0026#34;); if (!toc) { return; } // 监听滚动 window.addEventListener(\u0026#39;scroll\u0026#39;, function() { // 获取active-class let currentLi = document.querySelector(\u0026#34;.active-class\u0026#34;); if (!currentLi) { return } //清除class值 let elementsByClassName = document.querySelectorAll(\u0026#34;.open\u0026#34;); if (elementsByClassName.length \u0026gt; 0) { elementsByClassName.forEach((ul) =\u0026gt; { ul.classList.remove(\u0026#34;open\u0026#34;) }) } // 展示子ul if (currentLi.children.length \u0026gt; 1) { currentLi.children[1].classList.add(\u0026#34;open\u0026#34;) } // 展示父ul let ul = currentLi.parentElement; do { ul.classList.add(\u0026#34;open\u0026#34;); ul = ul.parentElement.parentElement } while (ul !== undefined \u0026amp;\u0026amp; (ul.localName === \u0026#39;ul\u0026#39; || ul.localName === \u0026#39;ol\u0026#39;)) }); } initTocHide() \u0026lt;/script\u0026gt; (2) 这样文章就会默认隐藏子目录，等滚动到对应的目录后，才会将子目录进行展示 6 添加\u0026rsquo;返回顶部\u0026rsquo;按钮 (1) 自行准备一张 返回顶部 的图片 ，放到assets/icons文件夹下(不存在则自行创建) (2) 将以下代码复制到layouts/partials/footer/custom.html文件中(不存在则自行创建)，修改css中的图片文件名，改成自己准备的图片名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;style\u0026gt; #backTopBtn { display: none; position: fixed; bottom: 30px; z-index: 99; cursor: pointer; width: 30px; height: 30px; background-image: url({{ (resources.Get \u0026#34;icons/图片文件名\u0026#34;).Permalink }}); } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; /** * 滚动回顶部初始化 */ function initScrollTop() { let rightSideBar = document.querySelector(\u0026#34;.right-sidebar\u0026#34;); if (!rightSideBar) { return; } // 添加返回顶部按钮到右侧边栏 let btn = document.createElement(\u0026#34;div\u0026#34;); btn.id = \u0026#34;backTopBtn\u0026#34;; btn.onclick = backToTop rightSideBar.appendChild(btn) // 滚动监听 window.onscroll = function() { // 当网页向下滑动 20px 出现\u0026#34;返回顶部\u0026#34; 按钮 if (document.body.scrollTop \u0026gt; 20 || document.documentElement.scrollTop \u0026gt; 20) { btn.style.display = \u0026#34;block\u0026#34;; } else { btn.style.display = \u0026#34;none\u0026#34;; } }; } /** * 返回顶部 */ function backToTop(){ window.scrollTo({ top: 0, behavior: \u0026#34;smooth\u0026#34; }) } initScrollTop(); \u0026lt;/script\u0026gt; (3) 这样当我们页面滚动到一定距离后，右下角会出现返回顶部的按钮，点击后可以平滑地返回顶部 7 macOS风格的代码块 (1) 准备一张macOS代码块的红绿灯图片(Ctrl+S保存), 放到static/icons文件夹下 (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .highlight { border-radius: var(--card-border-radius); max-width: 100% !important; margin: 0 !important; box-shadow: var(--shadow-l1) !important; } .highlight:before { content: \u0026#34;\u0026#34;; display: block; background: url(../icons/macOS-code-header.svg) no-repeat 0; background-size: contain; height: 18px; margin-top: -10px; margin-bottom: 10px; } 8 自定义MD引用块颜色模板 参考文章：让Hugo支持GitHub风格的块引用Alerts\n(1) 创建文件layouts/_default/_markup/render-blockquote-alert.html，并将以下代码复制进去\n1 2 3 \u0026lt;blockquote class=\u0026#34;alert alert-{{ .AlertType }}\u0026#34;\u0026gt; {{ .Text | safeHTML -}} \u0026lt;/blockquote\u0026gt; (2) 将以下代码复制进assets/scss/custom.scss文件中(不存在则自行创建) 配色参考来源：martignoni/hugo-notice 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 [data-scheme=\u0026#34;light\u0026#34;] { .alert-note { --card-separator-color: #65bbee; --blockquote-background-color: #e7f2fa; } .alert-tip { --card-separator-color: #55aa55; --blockquote-background-color: #eeffee; } .alert-warn { --card-separator-color: #ffbb78; --blockquote-background-color: #ffeecc; } .alert-error { --card-separator-color: #cc3334; --blockquote-background-color: #ffeeef; } } [data-scheme=\u0026#34;dark\u0026#34;] { .alert-note { --card-separator-color: #006699; --blockquote-background-color: #002234; } .alert-tip { --card-separator-color: #336733; --blockquote-background-color: #112310; } .alert-warn { --card-separator-color: #aa5501; --blockquote-background-color: #452300; } .alert-error { --card-separator-color: #880000; --blockquote-background-color: #450000; } } (3) 使用方法 可选项：NOTE | TIP | WARN | ERROR 可仿照上面css写法，自行添加新的css样式，来实现更多的可选项 1 2 \u0026gt; [!NOTE] \u0026gt; 这是markdown的引用块语法 (4) 效果演示 这是NOTE风格\n这是TIP风格\n这是WARN风格\n这是ERROR风格\n9 代码块过长折叠\u0026amp;展开 代码块折叠的样式风格完全仿照CSDN来实现的\n(1) 准备一张向下展开图片(Ctrl+S保存)，放到assets/icons目录下\n(2) 将以下代码复制进layouts/partials/footer/custom.html(文件不存在则自行创建)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;style\u0026gt; .highlight { /* 你可以根据需要调整这个高度 */ max-height: 400px; overflow: hidden; } .code-show { max-height: none !important; } .code-more-box { width: 100%; padding-top: 78px; background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff)); position: absolute; left: 0; right: 0; bottom: 0; z-index: 1; } .code-more-btn { display: block; margin: auto; width: 44px; height: 22px; background: #f0f0f5; border-top-left-radius: 8px; border-top-right-radius: 8px; padding-top: 6px; cursor: pointer; } .code-more-img { cursor: pointer !important; display: block; margin: auto; width: 22px; height: 16px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function initCodeMoreBox() { let codeBlocks = document.querySelectorAll(\u0026#34;.highlight\u0026#34;); if (!codeBlocks) { return; } codeBlocks.forEach(codeBlock =\u0026gt; { // 校验是否overflow if (codeBlock.scrollHeight \u0026lt;= codeBlock.clientHeight) { return; } // 元素初始化 // codeMoreBox let codeMoreBox = document.createElement(\u0026#39;div\u0026#39;); codeMoreBox.classList.add(\u0026#39;code-more-box\u0026#39;); // codeMoreBtn let codeMoreBtn = document.createElement(\u0026#39;span\u0026#39;); codeMoreBtn.classList.add(\u0026#39;code-more-btn\u0026#39;); codeMoreBtn.addEventListener(\u0026#39;click\u0026#39;, () =\u0026gt; { codeBlock.classList.add(\u0026#39;code-show\u0026#39;); codeMoreBox.style.display = \u0026#39;none\u0026#39;; }) // img let img = document.createElement(\u0026#39;img\u0026#39;); img.classList.add(\u0026#39;code-more-img\u0026#39;); img.src = {{ (resources.Get \u0026#34;icons/codeMore.png\u0026#34;).Permalink }} // 元素添加 codeMoreBtn.appendChild(img); codeMoreBox.appendChild(codeMoreBtn); codeBlock.appendChild(codeMoreBox) }) } initCodeMoreBox(); \u0026lt;/script\u0026gt; ","date":"2024-10-08T11:10:25+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/cover_hu782432619297144394.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-stack-theme/","title":"【Hugo】Stack主题自定义修改"},{"content":" 1. 基础引入 【Live2d-widget文档】 （1）查看官方文档，引入对应的js脚本到layouts\\partials\\footer\\custom.html中(详情看引入音乐播放器的文章) 1 2 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script src=\u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; （2）成功在左下角引入了live2d看板娘 2. 自定义适配 看板娘是已经引入好了，但是显示在左下角，跟我当前的主题非常的不搭，需要对看板娘进行自定义，来适配主题\n2.1 抽离autoload.js (1) 前往【Live2d-widget文档】，把 waifu-tips.json 和 waifu.css下载，并放到assets/waifu文件夹中(自己新建) (2) 把之前引入的 autoload.js 删掉，把下面代码引入到 custom.html 中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; // 获取博客本地资源地址 const cssPath = {{ (resources.Get \u0026#34;waifu/waifu.css\u0026#34;).Permalink }} const tipsJsonPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.json\u0026#34;).Permalink }} // live2d_path 参数建议使用绝对路径 const live2d_path = \u0026#34;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/\u0026#34;; // 封装异步加载资源的方法 function loadExternalResource(url, type) { return new Promise((resolve, reject) =\u0026gt; { let tag; if (type === \u0026#34;css\u0026#34;) { tag = document.createElement(\u0026#34;link\u0026#34;); tag.rel = \u0026#34;stylesheet\u0026#34;; tag.href = url; } else if (type === \u0026#34;js\u0026#34;) { tag = document.createElement(\u0026#34;script\u0026#34;); tag.src = url; } if (tag) { tag.onload = () =\u0026gt; resolve(url); tag.onerror = () =\u0026gt; reject(url); document.head.appendChild(tag); } }); } // 加载 waifu.css live2d.min.js waifu-tips.js if (screen.width \u0026gt;= 768) { Promise.all([ loadExternalResource(cssPath, \u0026#34;css\u0026#34;), loadExternalResource(live2d_path + \u0026#34;live2d.min.js\u0026#34;, \u0026#34;js\u0026#34;), loadExternalResource(live2d_path + \u0026#34;waifu-tips.js\u0026#34;, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { // 配置选项的具体用法见 README.md initWidget({ waifuPath: tipsJsonPath, cdnPath: \u0026#34;https://fastly.jsdelivr.net/gh/fghrsh/live2d_api/\u0026#34;, tools: [\u0026#34;hitokoto\u0026#34;, \u0026#34;asteroids\u0026#34;, \u0026#34;switch-model\u0026#34;, \u0026#34;switch-texture\u0026#34;, \u0026#34;photo\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;quit\u0026#34;] }); }); } \u0026lt;/script\u0026gt; 2.2 调整css样式 (1) 修改assets/waifu/waifu.css，将看板娘移动到右侧，更加适配Stack主题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 【waifu.css】 */ #waifu-toggle { ... /* left: 0; */ right: 0; /* margin-left: -100px; */ margin-right: -90px; /* writing-mode: vertical-rl; */ writing-mode: vertical-lr; } #waifu-toggle.waifu-toggle-active { /* margin-left: -50px; */ margin-right: -40px; } #waifu-toggle.waifu-toggle-active:hover { /* margin-left: -30px; */ margin-right: -20px; } #waifu { ... /* left: 0; */ right: 10px; } #waifu-tool { ... /* right: -10px; */ margin-left: 260px; } (2) 这样看板娘就成功移动到右下角了 2.3 调整看板娘提示语 (1) 修改assets/waifu/waifu-tips.json，修改里面的css选择器，来适配页面内容元素，这边以复制按钮为例\n(2) 查看复制按钮的元素，属性为class=\u0026quot;copyCodeButton\u0026quot;\n(3) 修改assets/waifu/waifu-tips.json，新增or修改对应的文本，修改对应的css选择器 (4) 这样当我们鼠标移动到对应的元素之后，看板娘就会有对应的提示语 2.4 自定义模型 2.4.1 引入cdn (1) 前往【live2d_api】，下载代码，这仓库中的文件就是 live2d-widget 的所使用的模型\n(2) 修改model_list.json文件，来添加or删除live2d模型（若有属于自己的live2d模型，请将模型放到model文件夹下）\n(3) 引入live2d文件可以本地引入(具体看音乐播放器文章)，这次演示用cdn的形式引入，cdn使用的是【jsDelivr】\n(4) cdn引入不需要php文件，将多余的php文件删掉，只保留 model 和 model_list.json\n(5) github新建一个公有(public)仓库，将代码上传到仓库上，打标签(Tags)并发布(Releases)一个版本 (6) 修改layouts/partials/footer/custom.html文件中的cdnPath 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { initWidget({ ... // 有文件夹就在后面拼文件夹路径 cdnPath: \u0026#34;https://cdn.jsdelivr.net/gh/{用户名}/{仓库名}@{标签名}/\u0026#34;, ... }); }); } \u0026lt;/script\u0026gt; (7) 这样就成功通过cdn的形式引入自己的live2d模型文件 2.4.2 bug修复 如果你 model_list.json 中的 live2d模型分组 只有一组的时候，会存在bug，导致加载不出模型，需要进行修复\n(1) 前往【Live2d-widget】，下载 waifu-tips.js，并放到assets/waifu文件夹下，修改 custom.html 来引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const tipsJsPath = {{ (resources.Get \u0026#34;waifu/waifu-tips.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;) ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (2) 修改 waifu-tips.js 文件，全局搜索e=1,o=53，将内容改为e=0,o=0，这两个值是默认模型和默认皮肤，所以一旦模型分组小于2的时候，就会找不到模型(代码顺序从0开始数) (3) 打开浏览器，按F12打开控制台，清理 localStorage(本地存储) 中的数据 (4) 这样加载模型默认加载第0个模型，bug就修复了 3 优化 3.1 多皮肤切换修复 （1）某些模型是具有多皮肤的(例如22, 33之类的)，但切换皮肤按钮不生效，是因为cdn形式引入是不适配皮肤切换的\n（2）这边对cdn引入方式的皮肤切换功能做了适配，下载我修改过的 live2d.min.js ，放到assets/waifu下，通过本地的形式引入\nlive2d.min.js（Ctrl+S保存） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... const live2dJsPath = {{ (resources.Get \u0026#34;waifu/live2d.min.js\u0026#34;).Permalink }} ... if (screen.width \u0026gt;= 768) { Promise.all([ ... loadExternalResource(live2dJsPath, \u0026#34;js\u0026#34;), ... ]).then(() =\u0026gt; { ... }); } \u0026lt;/script\u0026gt; (3) 这样就能切换这些看板娘的皮肤了 3.2 拖拽看板娘 (1) 有时候看板娘在右下角可能有点碍事，阻碍到我们点击一些页面内容，给看板娘添加拖拽功能，将她拖走\n(2) 将下面的代码复制进layouts\\partials\\footer\\custom.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;script\u0026gt; ... if (screen.width \u0026gt;= 768) { Promise.all([ ... ]).then(() =\u0026gt; { ... // 初始化看板娘鼠标监听事件 initWaifuMouseEvent(); }); } function initWaifuMouseEvent() { const waifu = document.getElementById(\u0026#34;waifu\u0026#34;); let isDown = false; let waifuLeft; let mouseLeft; let waifuTop; let mouseTop; // 鼠标点击监听 waifu.onmousedown = function (e) { isDown = true; // 记录x轴 waifuLeft = waifu.offsetLeft; mouseLeft = e.clientX; // 记录y轴 waifuTop = waifu.offsetTop; mouseTop = e.clientY; } // 鼠标移动监听 window.onmousemove = function (e) { if (!isDown) { return; } // x轴移动 let currentLeft = waifuLeft + (e.clientX - mouseLeft); if (currentLeft \u0026lt; 0) { currentLeft = 0; } else if (currentLeft \u0026gt; window.innerWidth - 300) { currentLeft = window.innerWidth - 300; } waifu.style.left = currentLeft + \u0026#34;px\u0026#34;; // y轴移动 let currentTop = waifuTop + (e.clientY - mouseTop); if (currentTop \u0026lt; 30) { currentTop = 30 } else if (currentTop \u0026gt; window.innerHeight - 290) { currentTop = window.innerHeight - 290 } waifu.style.top = currentTop + \u0026#34;px\u0026#34;; } // 鼠标点击松开监听 window.onmouseup = function (e) { isDown = false; } } \u0026lt;/script\u0026gt; (3) 这样就可以随意拖拽看板娘了（如果是没有腿的模型，建议把y轴移动的代码注释掉） ","date":"2024-09-19T17:17:34+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/cover_hu3013000311457165536.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-live2d/","title":"【Hugo】Live2d-widget 给博客引入萌萌的看板娘"},{"content":" 1 引入音乐播放器 【Aplayer官方文档】\n（1）在博客主目录中创建文件layouts\\partials\\footer\\custom.html，此文件为Stack主题作者留给我们加入自定义组件用的文件(可以查看主题源码同路径文件找到) （2）查看官方文档，引入对应的脚本，css到custom.html中，页面最下面就会出现音乐播放器\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 【custom.html】 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;aplayer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const ap = new APlayer({ container: document.getElementById(\u0026#39;aplayer\u0026#39;), audio: [] }); \u0026lt;/script\u0026gt; （3）修改 ap对象 配置，改成吸底模式 1 2 3 4 5 const ap = new APlayer({ ..., // 吸底模式 fixed: true }); （4）填写 audio 数组，引入歌曲，封面和歌词 lrcType 的值具体看【文档】 歌曲，封面，歌词支持远程链接 or 本地路径 若想通过本地路径引入，请将资源文件放在static文件夹下，通过hugo方法{{ .Site.Home.Permalink }}，获取网站主路径来拼接文件路径，进行引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const staticDir = {{ .Site.Home.Permalink }} const ap = new APlayer({ ..., lrcType: 3, audio: [ { name: \u0026#39;name\u0026#39;, // 歌名 artist: \u0026#39;artist\u0026#39;, // 歌手 url: \u0026#39;url.mp3\u0026#39;, // 歌曲路径 cover: \u0026#39;cover.jpg\u0026#39;, // 封面路径 lrc: \u0026#39;lrc.lrc\u0026#39;, // 歌词路径 }, { // 本地路径引入写法（有子目录就在staticDir后面继续拼接） name: \u0026#39;name\u0026#39;, artist: \u0026#39;artist\u0026#39;, url: staticDir + \u0026#39;url.mp3\u0026#39;, cover: staticDir + \u0026#39;cover.jpg\u0026#39;, lrc: staticDir + \u0026#39;lrc.lrc\u0026#39;, } ] }); 到这一步音乐播放器已经引入完了\n2 音乐播放器样式切换 （1）通过阅读Stack主题的源码可以看到，主题样式的切换是通过[data-scheme=\u0026quot;light/darck\u0026quot;] {...}\n（2）所以我们可以准备两种Aplayer的css，用[data-scheme=\u0026quot;light\u0026quot;]{ 亮的css样式 }包裹亮的，用[data-scheme=\u0026quot;dark\u0026quot;]{ 暗的css样式 }包裹暗的，这里直接给各位准备好了\naplayer-light.scss（Ctrl+S保存） aplayer-dark.scss（Ctrl+S保存） （3）在博客主目录中创建文件assets\\scss\\custom.scss，此文件为Stack主题作者留给我们加入自定义样式用的文件(可以查看主题源码同路径文件找到) （4）将上述两个scss文件放到跟 custom.scss同目录下，并通过@import来进行引入文件\n1 2 3 4 5 /** * 【custom.scss】 */ @import \u0026#34;aplayer-light.scss\u0026#34;; @import \u0026#34;aplayer-dark.scss\u0026#34;; （5）因为音乐播放器的css改为我们本地文件引入了，所以 custom.html 中的link标签可以将它注释掉或者删掉了 1 2 3 \u0026lt;!-- custom.html --\u0026gt; ... \u0026lt;!-- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css\u0026#34;\u0026gt; --\u0026gt; 到这一步样式随主题切换已经完成了\n3 音乐播放进度保留 （1）实现思路：页面切换前，把歌曲的 歌曲序号，播放时长，播放状态 记录下来；在页面切换加载完之后，我们调用Aplayer的接口切换歌曲，调整时长，并选择播放or暂停\n（2）通过console.log(ap)打印ap对象，或者官方文档，可以找到我们需要的参数\nlist.index：歌曲序号 audio.currentTime：播放时长 paused ：播放状态（是否暂停） （3）通过【官方文档】可以查找到我们需要调用的接口\nap.list.switch(index: number)：切换歌曲 ap.seek(time: number)：调整时长 ap.play()：播放歌曲 （4）需要的东西已经找齐，只需在 custom.html 加入以下代码即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... /** * 页面销毁前监听 */ window.onbeforeunload = () =\u0026gt; { // 将播放信息用对象封装，并存入到localStorage中 const playInfo = { index: ap.list.index, currentTime: ap.audio.currentTime, paused: ap.paused }; localStorage.setItem(\u0026#34;playInfo\u0026#34;, JSON.stringify(playInfo)); }; /** * 页面加载后监听 */ window.onload = () =\u0026gt; { // 从localStorage取出播放信息 const playInfo = JSON.parse(localStorage.getItem(\u0026#34;playInfo\u0026#34;)); if (!playInfo) { return; } // 切换歌曲 ap.list.switch(playInfo.index); // 等待500ms再执行下一步(切换歌曲需要点时间，不能立马调歌曲进度条) setTimeout(() =\u0026gt; { // 调整时长 ap.seek(playInfo.currentTime); // 是否播放 if (!playInfo.paused) { ap.play() } }, 500); }; \u0026lt;/script\u0026gt; 到这一步音乐播放进行已经完成了\n4 引入PJAX 4.1 基本引入 （1）PJAX主要分为两个版本，带JQuery 和 不带JQuery的，下面我演示的是不带JQuery版本的\n【defunkt/jquery-pjax】（带JQuery） 【MoOx/pjax】（不带JQuery） （2）分析页面元素，看哪些是需要我们重新加载的，可以发现是左侧边栏，中间内容，右侧边栏 （3）查看页面源代码，可以发现这些元素都被一个\u0026lt;div class=\u0026quot;main-container\u0026quot;\u0026gt;...\u0026lt;/div\u0026gt;包裹着，所以我们将这元素定为要刷新的对象 （4）根据官方文档，在 custom.html 加入以下代码来引入PJAX\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pjax/pjax.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ \u0026#34;.main-container\u0026#34; ] }) \u0026lt;/script\u0026gt; 这样算是已经基本引入了PJAX，但也带来了不少问题，我们一步一步进行修复\n4.2 文章样式修复 （1）随便点进其中一篇文章，可以发现文章内容的样式丢失，缺少文章该有的边框 （2）通过手动刷新，对比页面元素发现，决定文章样式的是\u0026lt;body\u0026gt; 标签中的class名: article-page，存在此class名就会识别到文章该有的css （3）因为\u0026lt;body\u0026gt;内包含整个页面的所有内容，包括我们的音乐播放器，所以不能让PJAX监听\u0026lt;body\u0026gt;标签\n阅读官方文档发现，官方提供了数据预处理方法，让我们处理数据 我们通过预处理数据，获取到新页面的className，然后我们手动将这className设置到\u0026lt;body\u0026gt;上 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... pjax._handleResponse = pjax.handleResponse; pjax.handleResponse = function(responseText, request, href, options) { if (request.responseText.match(\u0026#34;\u0026lt;html\u0026#34;)) { // 将新页面的html字符串解析成DOM对象 let newDom = new DOMParser().parseFromString(responseText, \u0026#39;text/html\u0026#39;); // 获取新页面中body的className，并设置回当前页面 let bodyClass = newDom.body.className; document.body.setAttribute(\u0026#34;class\u0026#34;, bodyClass) // 放行，交给pjax自己处理 pjax._handleResponse(responseText, request, href, options); } else { // handle non-HTML response here } } \u0026lt;/script\u0026gt; 这样我们切页面后，都会自动把body中的className更新，就不会丢失样式了\n4.3 主题切换修复 （1）当我们切换页面后，点击左下角切换主题颜色的按钮，会发现没有效果，主题颜色切换失效了 （2）阅读Stack主题源码\\assets\\ts\\colorScheme.ts发现，在脚本初始化时，会给元素绑定一个点击事件。但因为页面切换了，替换了该元素，但该元素没有重新绑定点击事件，导致点击主题切换失效 （3）解决思路：在PJAX切换完页面后，重新执行一遍colorScheme.ts的初始化，使元素重新绑定点击事件。\n阅读源码，发现colorScheme.ts被main.ts引用，在main.ts中执行了初始化，并且main.ts生成了个全局变量 Stack 所以在PJAX执行完后，使用全局变量 Stack ，执行里面的初始化方法，重新执行一遍脚本，来绑定点击事件 阅读PJAX文档，发现官方也提供了PJAX执行完后的事件，我们执行监听这个事件，Stack 执行初始化就好 1 2 3 4 5 6 7 8 9 \u0026lt;!-- 【custom.html】 --\u0026gt; ... \u0026lt;script\u0026gt; ... document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { // Stack脚本初始化 window.Stack.init(); }) \u0026lt;/script\u0026gt; 这样元素的点击事件重新绑定，主题颜色就能正常切换了\n4.4 文章搜索修复 （1）使用文章搜索功能时，输入关键词，无任何搜索记录，搜索功能失效 （2）查看layouts\\ts\\search.tsx文件，发现情况和上面的colorScheme.ts类似，存在绑定事件 （3）解决思路类似上面的，把 search.tsx 初始化内容，封装为一个函数，并把函数 export 出来，由 main.ts 引入这个函数，并放到 Stack.init() 的方法中，利用此方法来重新初始化搜索脚本 - （以下操作请复制同路径同名文件到自己主目录下修改，不要在主题源码中修改） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * 【search.tsx】 * 记得把window.addEventListener(\u0026#39;load\u0026#39; ...这部分代码注释掉 * 初始化工作交给Stack.init()处理了，不需要这个了 */ ... function searchInit() { let search = document.querySelector(\u0026#39;.search-result\u0026#39;); if (search) { const searchForm = document.querySelector(\u0026#39;.search-form\u0026#39;) as HTMLFormElement, searchInput = searchForm.querySelector(\u0026#39;input\u0026#39;) as HTMLInputElement, searchResultList = document.querySelector(\u0026#39;.search-result--list\u0026#39;) as HTMLDivElement, searchResultTitle = document.querySelector(\u0026#39;.search-result--title\u0026#39;) as HTMLHeadingElement; new Search({ form: searchForm, input: searchInput, list: searchResultList, resultTitle: searchResultTitle, resultTitleTemplate: window.searchResultTitleTemplate }); } } export { searchInit } 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【main.ts】 */ ... import { searchInit } from \u0026#34;ts/search\u0026#34;; let Stack = { init: () =\u0026gt; { ... // 调用search脚本初始化方法 searchInit(); } } （4）tsx 类型的文件引入方式有点特殊，需要我们修改以下 main.ts 的引入方式，修改layouts\\partials\\footer\\components\\script.html，改法参考layouts\\page\\search.html，把\u0026quot;JSXFactory\u0026quot; \u0026quot;createElement\u0026quot;补充上就好 这样search.tsx能正常初始化，文章搜索功能恢复\n4.5 搜索内容跳转修复 （1）虽然文章搜索已经修复了，但搜索出来的内容并没有被PJAX识别到，导致PJAX没有拦截，进而导致页面刷新了\n（2）阅读 search.tsx 源码可知，搜索内容的数据，是通过 React.render() ，动态渲染回页面的，这些动态数据没有被PJAX识别到。阅读PJAX文档，官方提供给了我们重新解析数据的方法，所以在 React.render() 之后，调用PJAX方法，重新解析页面即可 1 2 3 4 5 6 7 8 9 10 11 12 /** * 【search.tsx】 */ private async doSearch(keywords: string[]) { ... /* 方法末尾，让pjax重新解析文档数据，识别动态渲染的数据 虽然当前文件没有pjax对象，但最后静态页面会生成一个整体的js文件 pjax对象那时就能识别到，就可成功调用 */ pjax.refresh(document); } 这样动态渲染出的页面数据就能被PJAX识别到，就不会刷新页面跳转了\n4.6 文章评论修复 （1）如果博客有开启评论功能的话，会发现评论的脚本不生效了\n（2）由于每个人使用的评论种类各不相同，所以这边也是简单说一下。PJAX官方文档也有说如何处理：\n用一个\u0026lt;div class=js-Pjax\u0026gt;\u0026lt;/div\u0026gt;来包裹一个\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; 在\u0026lt;script\u0026gt;标签中，通过document.createElement('script')形式，创建对应的评论脚本内容 pjax对象通过 .js-Pjax 被识别到此内容，进行脚本执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;!-- custom.thml --\u0026gt; ... \u0026lt;script\u0026gt; var pjax = new Pjax({ selectors: [ ... \u0026#34;.js-Pjax\u0026#34; ] }) \u0026lt;/script\u0026gt; \u0026lt;div class=\u0026#34;js-Pjax\u0026#34;\u0026gt; \u0026lt;script\u0026gt; // TODO: 判断当前是否是文档，且是否开启评论功能 (function() { let script = document.createElement(\u0026#39;script\u0026#39;); // 将对应评论的脚本内容填进去 script.setAttribute(\u0026#39;key\u0026#39;, \u0026#39;value\u0026#39;); ... // 寻找合适的元素，添加脚本进去 document.querySelector(\u0026#39;xxx\u0026#39;).appendchild(script) })(document) \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 这样PJAX会自动加载我们的评论脚本\n5 引入进度条 （1）由于使用了PJAX后，无法得知页面的加载情况是否完成，所以引入一个伪进度条，来显示页面内容进度\n（2）前往【topbar】，点击下载zip包，将解压后的 topbar.min.js 放到assets\\js\\topbar.min.js （3）通过监听PJAX两个事件 pjax:send 和 pjax:complete 实现伪进度条\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!--custom.html--\u0026gt; ... {{ with resources.Get \u0026#34;js/topbar.min.js\u0026#34; }} \u0026lt;!-- 引入本地JS脚本 --\u0026gt; \u0026lt;script src={{ .Permalink }}\u0026gt;\u0026lt;/script\u0026gt; {{ end }} \u0026lt;script\u0026gt; // 修改进度条颜色 topbar.config({ barColors: { \u0026#39;0\u0026#39;: \u0026#39;rgba(255, 255, 255, 1)\u0026#39;, // 进度0%白色 \u0026#39;1.0\u0026#39;: \u0026#39;rgba(0, 149, 234, 1)\u0026#39; // 进度100%蓝色 } }) document.addEventListener(\u0026#39;pjax:send\u0026#39;, () =\u0026gt; { // 显示顶部进度条 topbar.show(); }) document.addEventListener(\u0026#39;pjax:complete\u0026#39;, () =\u0026gt; { .... // 隐藏顶部进度条 topbar.hide(); }) \u0026lt;/script\u0026gt; 这样伪进度条就成功引入了，能大概知道页面的加载情况了\n","date":"2024-08-14T14:50:54+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/cover_hu6146897835255991630.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-player/","title":"【Hugo】APlayer + PJAX 引入音乐播放放器并实现音乐不中断功能"},{"content":" 1 环境准备 1.1 Git下载 前往【Git官网】，下载安装程序 一直点下一步，默认安装即可 1.2 Hugo下载 前往【Hugo Github Tags】，选择对应版本下载，下载后解压即可 Windows下载版本：hugo_extended_xxxxx_windows_amd64.zip 2 搭建博客 2.1 创建博客 （1）在hugo.exe所在文件夹的地址栏敲打cmd，然后Enter唤起命令行 （2）敲打命令hugo new site xxxx创建hugo文件 （3）敲打命名cd xxxx切换目录，并把hugo.exe复制到刚生成的文件夹中 （4）敲打命令hugo server -D启动服务，访问http://localhost:1313，Ctrl+C停止服务 （hugo默认是没有主题的，需要进行主题配置） 2.2 配置主题 （1）前往【Hugo Themes】，查找自己喜欢的主题，进行下载 （2）这边以【Stack主题】为例，将下载好的主题解压，放到/themes文件夹中 （3）将exampleSite样例数据中的 Content 和 hugo.yaml 复制到主文件夹中，并删掉hugo.toml和content/post/rich-content （4）修改 hugo.yaml 中的 theme，将他修改为跟主题文件夹同名 （5）再次启动hugo服务，查看主题，具体主题配置修改 hugo.yaml，这里不细说，感兴趣可自行查找相关文章 3 Github部署 3.1 常规部署 （1）前往【Github官网】，创建仓库 {github用户名}.github.io （2）前往Setting -\u0026gt; Pages -\u0026gt; Branch选择main分支，然后保存，会自动开启 https://{github用户名}.github.io 的地址，这地址也是以后访问博客的地址 （3）回到hugo文件中，执行命令hugo -D，会生成 public 静态资源文件夹 （4）在 public 执行以下命令上传到github仓库上，第一次上传可能需要输入账号密码 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main （5）上传成功后访问 https://{github用户名}.github.io，成功搭建属于自己的Hugo博客 3.2 Github Action自动部署 （1）Github创建一个新的仓库，用于存放Hugo的主文件\n（2）前往Setttings -\u0026gt; Developer Settings -\u0026gt; Personal access tokens，创建一个token(classic)\n（3）token选择永不过期，并勾选 repo 和 workflow 选项 （4）为保证安全，将生成的token，保存的仓库的变量中，前往Settings -\u0026gt; Secrets and variables -\u0026gt; Actions中设置 （5）在hugo主文件创建一个.github/workflows/xxxx.yaml文件，将以下内容复制进去，想具体了解更多，可查看【Github Action文档】 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;latest\u0026#34; extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.你的token变量名 }} EXTERNAL_REPOSITORY: 你的github名/你的仓库名 PUBLISH_BRANCH: main PUBLISH_DIR: ./public commit_message: auto deploy （6）在hugo主文件创建.gitignore文件，来避免提交不必要的文件 1 2 3 4 5 6 7 # 自动生成的文件 public resources .hugo_build.lock # hugo命令 hugo.exe （7）将hugo的主文件上传到仓库，上传成功后会触发Github Action，来自动部署你的静态页面 1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main ","date":"2024-07-22T15:44:59+08:00","image":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/%E5%B0%81%E9%9D%A2_hu14931377072575281322.png","permalink":"https://letere-gzj.github.io/hugo-stack/p/hugo/custom-blog/","title":"【Hugo】Hugo + Github 免费部署自己的博客"}]